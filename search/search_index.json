{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TigerGraphX","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p> <p>TigerGraphX is designed for two main audiences, catering to different use cases while maintaining an easy-to-use, developer-friendly experience:</p>"},{"location":"#who-should-use-tigergraphx","title":"Who Should Use TigerGraphX?","text":""},{"location":"#1-python-developers-for-graph-analytics-with-tigergraph","title":"1. Python Developers for Graph Analytics with TigerGraph","text":"<p>If you\u2019re a Python developer interested in performing graph analytics with TigerGraph, TigerGraphX provides:</p> <ul> <li>Python-Native APIs: No need to learn complex query languages like GSQL or Cypher.</li> <li>Seamless Integration: Easily perform CRUD operations, multi-hop queries, and advanced analytics directly from Python.</li> <li>Scalability: Leverage the powerful performance of TigerGraph for large-scale graph processing.</li> </ul> <p>Start here:</p> <ul> <li>Introduction to TigerGraphX: Discover the features and benefits of using TigerGraphX for graph database management and analytics.</li> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>Quick Start Guide: Quickly set up TigerGraphX and build your first graph with this step-by-step guide.</li> </ul>"},{"location":"#2-python-developers-for-graphrag-workflows","title":"2. Python Developers for GraphRAG Workflows","text":"<p>If you\u2019re a Python developer building GraphRAG applications, TigerGraphX enables you to:</p> <ul> <li>Use TigerGraph as a scalable database for storing and retrieving graph and vector data generated by GraphRAG algorithms.</li> <li>Build token-aware LLM workflows for advanced AI applications.</li> <li>Utilize context builders to streamline data preparation for large language models.</li> </ul> <p>Start here:</p> <ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> <li>Supporting Microsoft\u2019s GraphRAG: An example of using TigerGraphX for GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"introduction/","title":"TigerGraphX: Unified Graph Solutions for Python Developers","text":""},{"location":"introduction/#what-is-tigergraphx","title":"What is TigerGraphX?","text":"<p>TigerGraphX is a high-level Python library offering a unified, Python-native interface for graph databases, advanced analytics, and GraphRAG workflows. Combining the simplicity of NetworkX with the advanced capabilities of TigerGraph, including tgCloud, it empowers Python developers to harness the power of graphs without the need to learn query languages like Cypher or GSQL.</p>"},{"location":"introduction/#core-mission","title":"Core Mission","text":"<p>TigerGraphX seeks to democratize graph technology by providing an intuitive, all-encompassing framework that integrates and provides direct connection to:</p> <ul> <li>TigerGraph Database capabilities</li> <li>TigerGraph Vector Database functionality</li> <li>Large Language Model (LLM) integration</li> <li>TigerGraph\u2019s GraphRAG support for intelligent workflow</li> </ul>"},{"location":"introduction/#key-features","title":"Key Features","text":""},{"location":"introduction/#1-schema-management","title":"1. Schema Management","text":"<ul> <li>Easily create and modify schemas using YAML, JSON, or Python dictionaries.</li> <li>No GSQL knowledge is required.</li> <li>Pythonic tools for designing database structures effortlessly.</li> </ul>"},{"location":"introduction/#2-data-loading","title":"2. Data Loading","text":"<ul> <li>Automated loading jobs for streamlined data imports.</li> <li>High-efficiency workflows with support for Parquet files.</li> <li>Simplified data ingestion processes for faster setup.</li> </ul>"},{"location":"introduction/#3-graph-library-interface","title":"3. Graph Library Interface","text":"<ul> <li>Python-native APIs for CRUD operations.</li> <li>Comprehensive tools for graph reporting and visualization.</li> <li>Built-in graph algorithms including centrality, community detection, and path analysis algorithms</li> </ul>"},{"location":"introduction/#4-graph-query-interface","title":"4. Graph Query Interface","text":"<ul> <li>Simplified advanced querying with intuitive APIs.</li> <li>Seamless integration into analytics workflows via DataFrame outputs.</li> <li>Support for advanced multi-hop query traversal and manipulation</li> </ul>"},{"location":"introduction/#5-vector-search-capabilities","title":"5. Vector Search Capabilities","text":"<ul> <li>AI-driven applications with integrated vector embeddings.</li> <li>Efficient top-K entity retrieval for enhanced intelligence.</li> <li>Ideal for recommendation systems and contextual analysis.</li> </ul>"},{"location":"introduction/#6-llm-integration-and-graphrag-support","title":"6. LLM Integration and GraphRAG support","text":"<ul> <li>Full support for GraphRAG workflows.</li> <li>Flexible, token-aware context builders for advanced applications.</li> <li>Tools for token optimization and seamless LLM integration.</li> </ul>"},{"location":"introduction/#7-machine-learning-ready-planned-feature","title":"7. Machine Learning Ready [Planned Feature]","text":"<ul> <li>Seamless integration with popular ML libraries</li> <li>Graph feature extraction</li> <li>Native support for graph neural networks (GNNs)</li> </ul>"},{"location":"introduction/#why-choose-tigergraphx","title":"Why Choose TigerGraphX?","text":"<p>TigerGraphX redefines graph technology by making advanced and powerful graph operations accessible and intuitive for Python developers. With its unified, user-friendly interface, TigerGraphX bridges the gap between simplicity and scalability, enabling developers to:</p> <ul> <li>Leverage TigerGraph\u2019s unmatched scalability for high-performance graph processing.  </li> <li>Enjoy the familiarity of tools like NetworkX while unlocking enterprise-grade graph capabilities.  </li> <li>Access advanced graph analytics with ease, reducing the learning curve and technical barriers.  </li> <li>Develop intelligent, context-aware GraphRAG applications effortlessly with token-aware workflows and streamlined context builders.</li> </ul> <p>TigerGraphX empowers developers to explore, analyze, and build with graphs like never before\u2014efficiently and effectively.</p>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started: Learn how to install and set up TigerGraphX.</li> <li>GraphRAG Overview: Explore how TigerGraphX integrates with GraphRAG workflows.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/installation/","title":"Installation Guide","text":"<p>Follow this guide to install and set up TigerGraphX in your environment.</p>"},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<p>This project requires Python 3.12 and TigerGraph. Ensure you meet the following prerequisites before proceeding:</p>"},{"location":"getting_started/installation/#1-python-312","title":"1. Python 3.12","text":"<ul> <li>Please ensure Python 3.12 is installed on your system.</li> <li>You can download and install it from the official Python website.</li> </ul>"},{"location":"getting_started/installation/#2-tigergraph","title":"2. TigerGraph","text":"<p>TigerGraph is required for this project and can be set up in one of the following ways:</p> <ul> <li>TigerGraph DB: Install and configure a local instance of TigerGraph.</li> <li>TigerGraph Cloud: Use a cloud-hosted instance of TigerGraph.</li> </ul> <p>It is recommended to use TigerGraph LTS (Long-Term Support) Versions, which can be downloaded from the TigerGraph Downloads page. To enable support for TigerVector and leverage advanced features like hybrid retrieval, ensure you are using TigerGraph 4.2 or above.</p> <p>Refer to the official TigerGraph Documentation for detailed installation and configuration instructions.</p>"},{"location":"getting_started/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"getting_started/installation/#option-1-install-from-pypi","title":"Option 1: Install from PyPI","text":"<p>The simplest way to get started with TigerGraphX is by installing it directly from PyPI. Using a virtual environment is recommended to ensure a clean and isolated setup.</p> <p>To install TigerGraphX, run: <pre><code>pip install tigergraphx\n</code></pre></p> <p>This allows you to quickly start using the library without needing the source code.</p>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installing, verify that TigerGraphX is installed correctly by running: <pre><code>python -c \"import tigergraphx; print('TigerGraphX installed successfully!')\"\n</code></pre></p> <p>If the installation was successful, you will see: <pre><code>TigerGraphX installed successfully!\n</code></pre></p> <p>This ensures that the library is properly installed and ready for use.</p>"},{"location":"getting_started/installation/#option-2-build-from-source-code","title":"Option 2: Build from Source Code","text":"<p>If you want to modify or explore the source code, you can install TigerGraphX from its GitHub repository. The source code is available here: TigerGraphX on GitHub.</p> <p>This project uses Poetry to manage dependencies. If you don\u2019t have Poetry installed, follow the instructions on the Poetry website.</p> <p>Once Poetry is installed, clone the repository, navigate to the project\u2019s root directory, and use one of the following commands to install dependencies based on your needs:</p>"},{"location":"getting_started/installation/#core-installation","title":"Core Installation","text":"<p>If you need only the core functionality of TigerGraphX (without running application examples like GraphRAG, unit tests, or integration tests), run: <pre><code>poetry install --without dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install only the dependencies required for the core features of TigerGraphX.</li> </ul>"},{"location":"getting_started/installation/#development-installation","title":"Development Installation","text":"<p>If you\u2019re contributing to the project or want to use advanced features like running the GraphRAG examples or test cases, run: <pre><code>poetry install --with dev\n</code></pre></p> <p>This command will:</p> <ul> <li>Install all core dependencies.</li> <li>Include development dependencies defined under <code>[tool.poetry.group.dev.dependencies]</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"getting_started/installation/#verify-your-installation","title":"Verify Your Installation","text":"<p>After installing dependencies, verify your setup by listing the installed packages: <pre><code>poetry show --with dev\n</code></pre></p> <p>This ensures all required dependencies (including optional ones) are successfully installed.</p>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Learn how to build your first graph with TigerGraphX.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"getting_started/quick_start/","title":"Quick Start Guide","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph, GraphSchema, TigerGraphConnectionConfig\ngraph_schema = GraphSchema.ensure_config({\n    \"graph_name\": \"Social\",\n    \"nodes\": {\n        \"Person\": {\n            \"primary_key\": \"name\",\n            \"attributes\": {\n                \"name\": \"STRING\",\n                \"age\": \"UINT\",\n            },\n        },\n    },\n    \"edges\": {\n        \"Friendship\": {\n            \"is_directed_edge\": False,\n            \"from_node_type\": \"Person\",\n            \"to_node_type\": \"Person\",\n            \"attributes\": {\n                \"closeness\": \"DOUBLE\",\n            },\n        },\n    },\n})\n</pre> from tigergraphx import Graph, GraphSchema, TigerGraphConnectionConfig graph_schema = GraphSchema.ensure_config({     \"graph_name\": \"Social\",     \"nodes\": {         \"Person\": {             \"primary_key\": \"name\",             \"attributes\": {                 \"name\": \"STRING\",                 \"age\": \"UINT\",             },         },     },     \"edges\": {         \"Friendship\": {             \"is_directed_edge\": False,             \"from_node_type\": \"Person\",             \"to_node_type\": \"Person\",             \"attributes\": {                 \"closeness\": \"DOUBLE\",             },         },     }, }) In\u00a0[2]: Copied! <pre>connection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\n</pre> connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", }) In\u00a0[3]: Copied! <pre>G = Graph(graph_schema, connection)\n</pre> G = Graph(graph_schema, connection) In\u00a0[4]: Copied! <pre>G.add_node(\"Alice\", \"Person\", age=25)\nG.add_node(\"Michael\", \"Person\", age=28)\nG.add_edge(\"Alice\", \"Michael\", closeness=0.98)\n</pre> G.add_node(\"Alice\", \"Person\", age=25) G.add_node(\"Michael\", \"Person\", age=28) G.add_edge(\"Alice\", \"Michael\", closeness=0.98) In\u00a0[5]: Copied! <pre>print(G.has_node(\"Alice\"))\n</pre> print(G.has_node(\"Alice\")) <pre>True\n</pre> In\u00a0[6]: Copied! <pre>print(G.has_node(\"Michael\"))\n</pre> print(G.has_node(\"Michael\")) <pre>True\n</pre> <p>Since the 'Friendship' edge is undirected, both 'Alice -&gt; Michael' and 'Michael -&gt; Alice' are valid and accessible.</p> In\u00a0[7]: Copied! <pre>print(G.has_edge(\"Alice\", \"Michael\"))\n</pre> print(G.has_edge(\"Alice\", \"Michael\")) <pre>True\n</pre> In\u00a0[8]: Copied! <pre>print(G.has_edge(\"Michael\", \"Alice\"))\n</pre> print(G.has_edge(\"Michael\", \"Alice\")) <pre>True\n</pre> In\u00a0[9]: Copied! <pre>print(G.get_node_data(\"Alice\"))\n</pre> print(G.get_node_data(\"Alice\")) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[10]: Copied! <pre>print(G.get_edge_data(\"Alice\", \"Michael\"))\n</pre> print(G.get_edge_data(\"Alice\", \"Michael\")) <pre>{'closeness': 0.98}\n</pre> In\u00a0[11]: Copied! <pre>print(G.nodes[\"Alice\"])\n</pre> print(G.nodes[\"Alice\"]) <pre>{'name': 'Alice', 'age': 25}\n</pre> In\u00a0[12]: Copied! <pre>print(G.nodes[\"Michael\"][\"age\"])\n</pre> print(G.nodes[\"Michael\"][\"age\"]) <pre>28\n</pre> <p>Note: The Edge View feature is planned for future releases.</p> In\u00a0[13]: Copied! <pre>print(G.degree(\"Alice\"))\n</pre> print(G.degree(\"Alice\")) <pre>1\n</pre> In\u00a0[14]: Copied! <pre>neighbors = G.get_neighbors(\"Alice\")\nprint(neighbors)\n</pre> neighbors = G.get_neighbors(\"Alice\") print(neighbors) <pre>      name  age\n0  Michael   28\n</pre> In\u00a0[15]: Copied! <pre>print(type(neighbors))\n</pre> print(type(neighbors)) <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\n</pre> In\u00a0[16]: Copied! <pre>print(G.number_of_nodes())\n</pre> print(G.number_of_nodes()) <pre>2\n</pre> In\u00a0[17]: Copied! <pre>print(G.number_of_edges())\n</pre> print(G.number_of_edges()) <pre>1\n</pre>"},{"location":"getting_started/quick_start/#quick-start-guide","title":"Quick Start Guide\u00b6","text":"<p>Follow this guide to quickly set up TigerGraphX and build your first graph. This guide assumes that you have already installed TigerGraphX and its dependencies as described in the Installation Guide.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from quick_start.ipynb.</p>"},{"location":"getting_started/quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"getting_started/quick_start/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will create a graph named \"Social\" that includes one node type, \"Person,\" and one directed edge type, \"Friendship.\" Note that you must define the primary key for each node type, indicate whether an edge type is directed or undirected, and specify the source and target node types for each edge type.</p>"},{"location":"getting_started/quick_start/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"getting_started/quick_start/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"getting_started/quick_start/#nodes-and-edges","title":"Nodes and Edges\u00b6","text":""},{"location":"getting_started/quick_start/#add-nodes-and-edges","title":"Add Nodes and Edges\u00b6","text":"<p>Note: This example demonstrates how to easily add nodes and edges using the API. However, adding nodes and edges individually may not be efficient for large-scale operations. For better performance when loading data into TigerGraph, it is recommended to use a loading job. Nonetheless, these examples are ideal for quickly getting started.</p>"},{"location":"getting_started/quick_start/#check-if-nodes-and-edges-exist","title":"Check if Nodes and Edges Exist\u00b6","text":""},{"location":"getting_started/quick_start/#display-node-and-edge-attributes","title":"Display Node and Edge Attributes\u00b6","text":""},{"location":"getting_started/quick_start/#using-get_node_data-and-get_edge_data-functions","title":"Using <code>get_node_data</code> and <code>get_edge_data</code> Functions\u00b6","text":""},{"location":"getting_started/quick_start/#using-node-view","title":"Using Node View\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-degree-of-nodes","title":"Display the Degree of Nodes\u00b6","text":""},{"location":"getting_started/quick_start/#retrieve-the-neighbors-of-a-node","title":"Retrieve the Neighbors of a Node\u00b6","text":""},{"location":"getting_started/quick_start/#graph-statistics","title":"Graph Statistics\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-number-of-nodes","title":"Display the Number of Nodes\u00b6","text":""},{"location":"getting_started/quick_start/#display-the-number-of-edges","title":"Display the Number of Edges\u00b6","text":""},{"location":"getting_started/quick_start/#whats-next","title":"What\u2019s Next?\u00b6","text":"<p>Now that you\u2019ve set up your graph and performed basic operations, you can explore more advanced features of TigerGraphX:</p> <ul> <li>GraphRAG Overview: Learn about integrating graphs with LLMs.</li> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start unlocking the power of graphs with TigerGraphX today!</p>"},{"location":"graphrag/graphrag_overview/","title":"TigerGraph: Unlocking the Potential of GraphRAG","text":""},{"location":"graphrag/graphrag_overview/#overview","title":"Overview","text":"<p>TigerGraph is a highly scalable and efficient graph database, making it the ideal foundation for advanced GraphRAG workflows. It excels in handling both graph and vector data, enabling seamless integration and performance at scale. With built-in support for complex queries, multi-hop traversals, and real-time analytics, TigerGraph ensures fast and reliable results. Its versatility and performance make it the ideal choice for powering data-intensive workflows, while TigerGraphX simplifies access with a Python-native interface.</p> <p></p>"},{"location":"graphrag/graphrag_overview/#why-tigergraph-for-graphrag","title":"Why TigerGraph for GraphRAG?","text":""},{"location":"graphrag/graphrag_overview/#1-scalability-and-performance","title":"1. Scalability and Performance","text":"<p>TigerGraph excels in handling massive datasets with high-speed multi-hop queries and vector search capabilities. It is ideal for real-world GraphRAG applications that demand extensive and efficient data processing.</p>"},{"location":"graphrag/graphrag_overview/#2-unified-graph-and-vector-data-support","title":"2. Unified Graph and Vector Data Support","text":"<p>With native support for schema-defined nodes, edges, and vectors, TigerGraph streamlines data integration. Its advanced query optimization enables efficient graph traversal and vector-based retrieval, which is perfectly suited for LLM workflows.</p>"},{"location":"graphrag/graphrag_overview/#3-cost-effectiveness","title":"3. Cost-Effectiveness","text":"<p>TigerGraph reduces computational overhead through optimized queries and highly efficient storage, significantly cutting infrastructure costs while maintaining top-tier performance.</p>"},{"location":"graphrag/graphrag_overview/#4-flexibility-and-hybrid-integration","title":"4. Flexibility and Hybrid Integration","text":"<p>Seamlessly combines structured, semantic, and vector-based retrieval methods in one unified platform. Its compatibility with vector search and LLMs enables advanced hybrid retrieval strategies, unlocking new possibilities for GraphRAG workflows.</p>"},{"location":"graphrag/graphrag_overview/#graphrag-workflow-with-tigergraph","title":"GraphRAG Workflow with TigerGraph","text":""},{"location":"graphrag/graphrag_overview/#1-schema-design","title":"1. Schema Design","text":"<p>Define the graph schema with nodes, edges, and attributes tailored to your application, leveraging TigerGraph\u2019s native support for structured graph data.</p>"},{"location":"graphrag/graphrag_overview/#2-data-preparation-and-loading","title":"2. Data Preparation and Loading","text":"<p>Transform raw data into TigerGraph-compatible formats, including graph structures and embeddings, and load it efficiently into TigerGraph using TigerGraphX.</p>"},{"location":"graphrag/graphrag_overview/#3-knowledge-graph-management-and-analysis","title":"3. Knowledge Graph Management and Analysis","text":"<p>Maintain and enhance the knowledge graph to ensure data quality, relevance, and scalability. Perform in-depth analysis to uncover patterns, infer insights, and optimize data retrieval strategies; ensure the knowledge graph remains a dynamic, accurate, and actionable source of information, enriching context for LLMs while supporting explainability and scalability in the GraphRAG workflow.</p>"},{"location":"graphrag/graphrag_overview/#4-hybrid-retrieval","title":"4. Hybrid Retrieval","text":"<p>Combine structured queries, semantic search, and vector-based methods to fetch relevant data and embeddings from TigerGraph for context construction.</p>"},{"location":"graphrag/graphrag_overview/#5-context-building","title":"5. Context Building","text":"<p>Use TigerGraphX to process retrieved data, making it token-aware and formatted to meet the requirements of LLMs.</p>"},{"location":"graphrag/graphrag_overview/#6-llm-integration","title":"6. LLM Integration","text":"<p>Pass the context to an LLM to generate responses, enabling advanced GraphRAG workflows with seamless data flow and high efficiency.</p>"},{"location":"graphrag/graphrag_overview/#two-options-for-implementing-graphrag-with-tigergraph","title":"Two Options for Implementing GraphRAG with TigerGraph","text":"<p>There are two approaches to implementing GraphRAG with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#1-tigergraph-as-a-storage-and-retrieval-engine","title":"1. TigerGraph as a Storage and Retrieval Engine","text":"<p>The first approach primarily utilizes TigerGraph for storing and retrieving graph/vector data. TigerGraphX provides interfaces similar to NetworkX, allowing seamless integration with GraphRAG applications. This approach is recommended for GraphRAG solutions like LightRAG and Nano-GraphRAG, which abstract their storage layers (e.g., graph storage, key-value storage, and vector storage). Here, you only need to implement these layers in a way that aligns with TigerGraph.</p>"},{"location":"graphrag/graphrag_overview/#2-tigergraph-for-storage-and-retrieval-tigergraphx-for-llm-tasks","title":"2. TigerGraph for Storage and Retrieval; TigerGraphX for LLM Tasks","text":"<p>The second approach extends beyond storage and retrieval by leveraging TigerGraphX for tasks related to large language models (LLMs), such as chat or embedding generation. This approach is suitable for complex projects like Microsoft's GraphRAG. As of December 2024, Microsoft's GraphRAG has not yet abstracted its storage layer, making it challenging to replace the indexing process. However, TigerGraphX can be used to convert the results of the indexing process (e.g., Parquet files) into a format supported by TigerGraph. These results can then be imported into TigerGraph, and TigerGraphX can handle the querying process without relying on Microsoft\u2019s GraphRAG.</p>"},{"location":"graphrag/graphrag_overview/#demonstrations","title":"Demonstrations","text":"<p>Both methods are demonstrated on the following pages, each with a real-world project:</p> <ul> <li>LightRAG: Refer to LightRAG for the first approach.</li> <li>Microsoft's GraphRAG: Refer to Microsoft GraphRAG: Part 1 for the second approach.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/lightrag/","title":"Supporting LightRAG","text":"<p>LightRAG is an open-source RAG system that enhances LLMs by integrating graph-based structures into text indexing and retrieval. It overcomes the limitations of traditional RAG systems, such as fragmented answers and weak contextual awareness, by enabling dual-level retrieval for more comprehensive knowledge discovery. With support for incremental data updates, LightRAG ensures timely integration of new information while delivering improved retrieval accuracy and efficiency.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from lightrag.ipynb.</p> In\u00a0[1]: Copied! <pre>import os\nfrom dataclasses import dataclass\nimport numpy as np\n\nfrom lightrag.base import BaseGraphStorage\nfrom lightrag.utils import logger\nfrom tigergraphx import UndiGraph, TigerGraphConnectionConfig\n\n\n@dataclass\nclass TigerGraphStorage(BaseGraphStorage):\n    def __post_init__(self):\n        try:\n            # Retrieve connection configuration from environment variables\n            connection_config = {\n                \"host\": os.environ[\"TG_HOST\"],\n                \"username\": os.environ[\"TG_USERNAME\"],\n                \"password\": os.environ[\"TG_PASSWORD\"],\n            }\n            logger.info(\"TigerGraph connection configuration retrieved successfully.\")\n            # Initialize the graph\n            self._graph = UndiGraph(\n                graph_name=\"LightRAG\",\n                node_type=\"MyNode\",\n                edge_type=\"MyEdge\",\n                node_primary_key=\"id\",\n                node_attributes={\n                    \"id\": \"STRING\",\n                    \"entity_type\": \"STRING\",\n                    \"description\": \"STRING\",\n                    \"source_id\": \"STRING\",\n                },\n                edge_attributes={\n                    \"weight\": \"DOUBLE\",\n                    \"description\": \"STRING\",\n                    \"keywords\": \"STRING\",\n                    \"source_id\": \"STRING\",\n                },\n                tigergraph_connection_config=TigerGraphConnectionConfig.ensure_config(\n                    connection_config\n                ),\n            )\n            logger.info(\n                \"Undirected graph initialized successfully with graph_name 'LightRAG'.\"\n            )\n        except KeyError as e:\n            logger.error(f\"Environment variable {str(e)} is missing.\")\n            raise\n        except Exception as e:\n            logger.error(f\"An error occurred during initialization: {e}\")\n            raise\n\n    @staticmethod\n    def clean_quotes(value: str) -&gt; str:\n        \"\"\"Remove leading and trailing &amp;quot; from a string if present.\"\"\"\n        if value.startswith('\"') and value.endswith('\"'):\n            return value[1:-1]\n        return value\n\n    async def has_node(self, node_id: str) -&gt; bool:\n        return self._graph.has_node(self.clean_quotes(node_id))\n\n    async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:\n        return self._graph.has_edge(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n\n    async def node_degree(self, node_id: str) -&gt; int:\n        result = self._graph.degree(self.clean_quotes(node_id))\n        return result\n\n    async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:\n        return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(\n            self.clean_quotes(tgt_id)\n        )\n\n    async def get_node(self, node_id: str) -&gt; dict | None:\n        result = self._graph.get_node_data(self.clean_quotes(node_id))\n        return result\n\n    async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:\n        result = self._graph.get_edge_data(\n            self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)\n        )\n        return result\n\n    async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:\n        source_node_id = self.clean_quotes(source_node_id)\n        if self._graph.has_node(source_node_id):\n            edges = self._graph.get_node_edges(source_node_id)\n            return list(edges)\n        return None\n\n    async def upsert_node(self, node_id: str, node_data: dict[str, str]):\n        node_id = self.clean_quotes(node_id)\n        self._graph.add_node(node_id, **node_data)\n\n    async def upsert_edge(\n        self, source_node_id: str, target_node_id: str, edge_data: dict[str, str]\n    ):\n        source_node_id = self.clean_quotes(source_node_id)\n        target_node_id = self.clean_quotes(target_node_id)\n        self._graph.add_edge(source_node_id, target_node_id, **edge_data)\n\n    async def delete_node(self, node_id: str):\n        if self._graph.has_node(node_id):\n            self._graph.remove_node(node_id)\n            logger.info(f\"Node {node_id} deleted from the graph.\")\n        else:\n            logger.warning(f\"Node {node_id} not found in the graph for deletion.\")\n\n    async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:\n        return np.array([]), []\n</pre> import os from dataclasses import dataclass import numpy as np  from lightrag.base import BaseGraphStorage from lightrag.utils import logger from tigergraphx import UndiGraph, TigerGraphConnectionConfig   @dataclass class TigerGraphStorage(BaseGraphStorage):     def __post_init__(self):         try:             # Retrieve connection configuration from environment variables             connection_config = {                 \"host\": os.environ[\"TG_HOST\"],                 \"username\": os.environ[\"TG_USERNAME\"],                 \"password\": os.environ[\"TG_PASSWORD\"],             }             logger.info(\"TigerGraph connection configuration retrieved successfully.\")             # Initialize the graph             self._graph = UndiGraph(                 graph_name=\"LightRAG\",                 node_type=\"MyNode\",                 edge_type=\"MyEdge\",                 node_primary_key=\"id\",                 node_attributes={                     \"id\": \"STRING\",                     \"entity_type\": \"STRING\",                     \"description\": \"STRING\",                     \"source_id\": \"STRING\",                 },                 edge_attributes={                     \"weight\": \"DOUBLE\",                     \"description\": \"STRING\",                     \"keywords\": \"STRING\",                     \"source_id\": \"STRING\",                 },                 tigergraph_connection_config=TigerGraphConnectionConfig.ensure_config(                     connection_config                 ),             )             logger.info(                 \"Undirected graph initialized successfully with graph_name 'LightRAG'.\"             )         except KeyError as e:             logger.error(f\"Environment variable {str(e)} is missing.\")             raise         except Exception as e:             logger.error(f\"An error occurred during initialization: {e}\")             raise      @staticmethod     def clean_quotes(value: str) -&gt; str:         \"\"\"Remove leading and trailing \" from a string if present.\"\"\"         if value.startswith('\"') and value.endswith('\"'):             return value[1:-1]         return value      async def has_node(self, node_id: str) -&gt; bool:         return self._graph.has_node(self.clean_quotes(node_id))      async def has_edge(self, source_node_id: str, target_node_id: str) -&gt; bool:         return self._graph.has_edge(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )      async def node_degree(self, node_id: str) -&gt; int:         result = self._graph.degree(self.clean_quotes(node_id))         return result      async def edge_degree(self, src_id: str, tgt_id: str) -&gt; int:         return self._graph.degree(self.clean_quotes(src_id)) + self._graph.degree(             self.clean_quotes(tgt_id)         )      async def get_node(self, node_id: str) -&gt; dict | None:         result = self._graph.get_node_data(self.clean_quotes(node_id))         return result      async def get_edge(self, source_node_id: str, target_node_id: str) -&gt; dict | None:         result = self._graph.get_edge_data(             self.clean_quotes(source_node_id), self.clean_quotes(target_node_id)         )         return result      async def get_node_edges(self, source_node_id: str) -&gt; list[tuple[str, str]] | None:         source_node_id = self.clean_quotes(source_node_id)         if self._graph.has_node(source_node_id):             edges = self._graph.get_node_edges(source_node_id)             return list(edges)         return None      async def upsert_node(self, node_id: str, node_data: dict[str, str]):         node_id = self.clean_quotes(node_id)         self._graph.add_node(node_id, **node_data)      async def upsert_edge(         self, source_node_id: str, target_node_id: str, edge_data: dict[str, str]     ):         source_node_id = self.clean_quotes(source_node_id)         target_node_id = self.clean_quotes(target_node_id)         self._graph.add_edge(source_node_id, target_node_id, **edge_data)      async def delete_node(self, node_id: str):         if self._graph.has_node(node_id):             self._graph.remove_node(node_id)             logger.info(f\"Node {node_id} deleted from the graph.\")         else:             logger.warning(f\"Node {node_id} not found in the graph for deletion.\")      async def embed_nodes(self, algorithm: str) -&gt; tuple[np.ndarray, list[str]]:         return np.array([]), [] <p>This code defines a <code>TigerGraphStorage</code> class that implements the <code>BaseGraphStorage</code> interface for graph storage and retrieval using TigerGraphX, a Python library for interacting with TigerGraph databases.</p> <p>Key highlights of this implementation include:</p> <ol> <li><p>Graph Initialization</p> <ul> <li>An undirected homogeneous graph (<code>UndiGraph</code>) is initialized. This graph type supports only one type of node and edge, making it similar to NetworkX's undirected graph.</li> <li>TigerGraph\u2019s schema-based nature requires a graph schema definition with specific attributes for nodes and edges. For instance:<ul> <li>Node attributes: <code>id</code>, <code>entity_type</code>, <code>description</code>, <code>source_id</code></li> <li>Edge attributes: <code>weight</code>, <code>description</code>, <code>keywords</code>, <code>source_id</code></li> </ul> </li> </ul> </li> <li><p>TigerGraphX Interfaces</p> <ul> <li>TigerGraphX provides user-friendly interfaces, very similar to NetworkX, which simplify operations like:<ul> <li>Node Operations: <code>has_node</code>, <code>add_node</code>, <code>remove_node</code>, <code>get_node_data</code></li> <li>Edge Operations: <code>has_edge</code>, <code>add_edge</code>, <code>get_edge_data</code>, <code>get_node_edges</code></li> <li>Degree Calculation: <code>degree</code> for nodes and edges.</li> </ul> </li> </ul> </li> <li><p>Key Methods</p> <ul> <li>Storage Operations:<ul> <li><code>upsert_node</code>: Inserts or updates a node with its data.</li> <li><code>upsert_edge</code>: Inserts or updates an edge between two nodes.</li> <li><code>delete_node</code>: Deletes a node if it exists.</li> </ul> </li> <li>Data Retrieval:<ul> <li><code>get_node</code>: Retrieves data for a specific node.</li> <li><code>get_edge</code>: Retrieves data for a specific edge.</li> <li><code>get_node_edges</code>: Retrieves all edges for a given node.</li> </ul> </li> <li>Graph Metrics:<ul> <li><code>node_degree</code>: Returns the degree of a node.</li> <li><code>edge_degree</code>: Calculates combined degrees of two nodes.</li> </ul> </li> </ul> </li> <li><p>Additional Notes</p> <ul> <li>The <code>clean_quotes</code> method ensures clean input values by stripping leading and trailing quotes from strings.</li> <li>TigerGraphX goes beyond NetworkX\u2019s capabilities by supporting heterogeneous graphs (graphs with multiple types of nodes and edges) using the <code>Graph</code> class, in addition to undirected (<code>UndiGraph</code>) and directed graphs (<code>DiGraph</code>).</li> </ul> </li> </ol> In\u00a0[2]: Copied! <pre>from lightrag import LightRAG\n\n\n# Define a subclass to include your custom graph storage in the storage mapping\nclass CustomLightRAG(LightRAG):\n    def _get_storage_class(self):\n        # Extend the default storage mapping with your custom storage\n        base_mapping = super()._get_storage_class()\n        base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage\n        return base_mapping\n</pre> from lightrag import LightRAG   # Define a subclass to include your custom graph storage in the storage mapping class CustomLightRAG(LightRAG):     def _get_storage_class(self):         # Extend the default storage mapping with your custom storage         base_mapping = super()._get_storage_class()         base_mapping[\"TigerGraphStorage\"] = TigerGraphStorage         return base_mapping In\u00a0[\u00a0]: Copied! <pre>import logging\nimport nest_asyncio\n# Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts.\nnest_asyncio.apply()\n\n\nworking_dir = \"../../applications/lightrag/data\"\n\ncustom_rag = CustomLightRAG(\n    working_dir=working_dir,\n    graph_storage=\"TigerGraphStorage\",\n)\n\nwith open(working_dir + \"/input/fin.txt\") as f:\n    custom_rag.insert(f.read())\n</pre> import logging import nest_asyncio # Use the nest_asyncio package to allow running nested event loops in Jupyter Notebook without conflicts. nest_asyncio.apply()   working_dir = \"../../applications/lightrag/data\"  custom_rag = CustomLightRAG(     working_dir=working_dir,     graph_storage=\"TigerGraphStorage\", )  with open(working_dir + \"/input/fin.txt\") as f:     custom_rag.insert(f.read()) <p>Note that the output has been cleared here because it is too long, and most of the information consists of logs.</p> In\u00a0[4]: Copied! <pre>from lightrag import QueryParam\n\ncustom_rag = CustomLightRAG(\n    working_dir=working_dir,\n    graph_storage=\"TigerGraphStorage\",\n)\n\nquery = \"What is the overall financial health of the company?\"\n\nresult = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))\n\nprint(\"------------------- Query Result:  -------------------\")\nprint(result)\n</pre> from lightrag import QueryParam  custom_rag = CustomLightRAG(     working_dir=working_dir,     graph_storage=\"TigerGraphStorage\", )  query = \"What is the overall financial health of the company?\"  result = custom_rag.query(query=query, param=QueryParam(mode=\"hybrid\"))  print(\"------------------- Query Result:  -------------------\") print(result) <pre>2024-12-19 17:14:49,355 - lightrag - INFO - Logger initialized for working directory: ../../applications/lightrag/data\n2024-12-19 17:14:49,357 - lightrag - INFO - Load KV llm_response_cache with 0 data\n2024-12-19 17:14:49,359 - lightrag - INFO - Load KV full_docs with 1 data\n2024-12-19 17:14:49,363 - lightrag - INFO - Load KV text_chunks with 46 data\n2024-12-19 17:14:49,364 - lightrag - INFO - TigerGraph connection configuration retrieved successfully.\n2024-12-19 17:14:49,498 - lightrag - INFO - Undirected graph initialized successfully with graph_name 'LightRAG'.\n2024-12-19 17:14:49,548 - nano-vectordb - INFO - Load (752, 1536) data\n2024-12-19 17:14:49,551 - nano-vectordb - INFO - Init {'embedding_dim': 1536, 'metric': 'cosine', 'storage_file': '../../applications/lightrag/data/vdb_entities.json'} 752 data\n2024-12-19 17:14:49,570 - nano-vectordb - INFO - Load (351, 1536) data\n2024-12-19 17:14:49,572 - nano-vectordb - INFO - Init {'embedding_dim': 1536, 'metric': 'cosine', 'storage_file': '../../applications/lightrag/data/vdb_relationships.json'} 351 data\n2024-12-19 17:14:49,577 - nano-vectordb - INFO - Load (46, 1536) data\n2024-12-19 17:14:49,577 - nano-vectordb - INFO - Init {'embedding_dim': 1536, 'metric': 'cosine', 'storage_file': '../../applications/lightrag/data/vdb_chunks.json'} 46 data\n2024-12-19 17:14:51,097 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n2024-12-19 17:14:51,099 - lightrag - INFO - kw_prompt result:\n{\n  \"high_level_keywords\": [\"Financial health\", \"Company performance\", \"Business analysis\"],\n  \"low_level_keywords\": [\"Revenue\", \"Profit margins\", \"Expenses\", \"Balance sheet\", \"Cash flow\", \"Debt\", \"Assets\"]\n}\n2024-12-19 17:14:51,602 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2024-12-19 17:14:54,174 - lightrag - INFO - Local query uses 60 entites, 35 relations, 3 text units\n2024-12-19 17:14:54,779 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"\n2024-12-19 17:14:56,517 - lightrag - INFO - Global query uses 44 entites, 60 relations, 3 text units\n2024-12-19 17:15:06,178 - httpx - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\n------------------- Query Result:  -------------------\n### Overview of Financial Health \n\nThe overall financial health of CytoSorbents Corporation can be assessed through its funding strategies, revenue generation, and partnerships contributing to its growth in medical technology specifically focusing on blood purification products, with a particular emphasis on the CytoSorb device.\n\n### Funding Sources and Capital Raising\n\nCytoSorbents has successfully raised approximately **$214 million** from investors through various funding mechanisms including public offerings, convertible note offerings, and equity transactions. A significant public offering occurred on **July 24, 2020**, where the company sold **6,052,631 shares at a price of $9.50 per share**, raising gross proceeds of about **$57.5 million**. After expenses, this resulted in net proceeds of **$53.8 million**. Additionally, a new sale agreement allows CytoSorbents to sell its common stock at market prices through financial agents, increasing flexibility in capital management. This indicates a robust ability to attract investment for development and research.\n\n### Revenue from Sales and Market Expansion\n\nCytoSorbents has generated revenue through the sales of its CytoSorb device, especially in significant markets like **Germany**, where it has established its presence and received important reimbursement codes aiding its integration into healthcare systems. The company has also initiated distribution partnerships, for example, with **Biocon Biologics Limited** for exclusive rights to market CytoSorb in India, and **Fresenius** for broader international reach. These partnerships are pivotal in enhancing sales potential and penetrating emerging markets.\n\n### Clinical Trials and Regulation\n\nCytoSorbents is actively engaged in multiple clinical trials aimed at validating its product in various applications, including ongoing studies addressing conditions like **sepsis** and **COVID-19**. The company received **Emergency Use Authorization (EUA)** from the FDA for CytoSorb during the COVID-19 pandemic, highlighting its responsiveness to market needs and ability to pivot in critical times. The successful conclusion of these trials is expected to bolster revenue further by allowing broader application and market access for CytoSorb.\n\n### Business Strategy and Future Outlook\n\nThe company has a sound strategy focusing on expanding its product pipeline, including technologies like **HemoDefend** and others targeting critical care applications. With various government contracts from organizations such as the **NHLBI** and **DARPA**, coupled with ongoing support from military funding agencies, CytoSorbents can continue its research and development initiatives, playing a crucial role in its financial health.\n\n### Conclusion\n\nIn summary, CytoSorbents Corporation shows a healthy financial trajectory characterized by robust funding efforts, strategic partnerships, and solid revenue streams from ongoing sales and clinical trials. While there are inherent risks associated with medical technology development and regulatory compliance, the company appears well-positioned for future growth and profitability through its innovative therapies aimed at severe medical conditions.\n</pre>"},{"location":"graphrag/lightrag/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li><p>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</p> </li> <li><p>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</p> </li> <li><p>Set the environment variables <code>TG_HOST</code>, <code>TG_USERNAME</code>, and <code>TG_PASSWORD</code>, which are required to connect to the TigerGraph server, as well as <code>OPENAI_API_KEY</code> for connecting to OpenAI. Use a command like the following to set these variables:</p> <pre>export TG_HOST=https://127.0.0.1\n</pre> </li> </ul>"},{"location":"graphrag/lightrag/#implement-graph-storage-with-tigergraphx","title":"Implement Graph Storage with TigerGraphX\u00b6","text":"<p>In LightRAG, the storage layers are abstracted into components such as graph storage, key-value storage, and vector storage. You can refer to the base classes BaseGraphStorage, BaseVectorStorage, and BaseKVStorage in the source code.</p> <p>In this section, we will demonstrate how to use TigerGraphX to implement the <code>BaseGraphStorage</code> class for storing and retrieving data in TigerGraph.</p>"},{"location":"graphrag/lightrag/#integrating-custom-graph-storage-with-lightrag","title":"Integrating Custom Graph Storage with LightRAG\u00b6","text":"<p>After defining the <code>TigerGraphStorage</code> class, we integrate it into LightRAG. By subclassing LightRAG and extending its storage mapping, you can easily replace or augment the default storage backends with your custom solution.</p> <p>While modifying the LightRAG source code is another option, this example demonstrates how to achieve the integration without altering the original source code.</p> <p>Below is the code for creating a <code>CustomLightRAG</code> class that incorporates <code>TigerGraphStorage</code> into its storage mapping.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":""},{"location":"graphrag/lightrag/#data-preparation","title":"Data Preparation\u00b6","text":""},{"location":"graphrag/lightrag/#set-up-working-directory","title":"Set Up Working Directory\u00b6","text":"<p>Create a folder to serve as the working directory. For this demo, we will use <code>applications/lightrag/data</code>.</p> <p>Next, create an <code>input</code> folder inside the <code>data</code> directory to store the documents you want to index:</p> <pre>mkdir -p applications/lightrag/data/input\n</pre>"},{"location":"graphrag/lightrag/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder\u00b6","text":"<p>Copy your documents (e.g., <code>fin.txt</code>) into the <code>applications/lightrag/data/input</code> folder.</p>"},{"location":"graphrag/lightrag/#indexing","title":"Indexing\u00b6","text":"<p>The following code sets up a working directory and demonstrates how to index a given document using LightRAG.</p>"},{"location":"graphrag/lightrag/#querying","title":"Querying\u00b6","text":"<p>The following code demonstrates how to perform a query in LightRAG using the TigerGraph graph storage implementation.</p>"},{"location":"graphrag/msft_graphrag_1/","title":"Supporting Microsoft\u2019s GraphRAG: Part 1","text":"<p>Microsoft's GraphRAG is a method for creating structured knowledge graphs from raw text, enhancing Retrieval Augmented Generation (RAG) tasks. By organizing information hierarchically, it enables more efficient data retrieval and summarization.</p>"},{"location":"graphrag/msft_graphrag_1/#what-youll-learn-in-this-guide","title":"What You\u2019ll Learn in This Guide","text":"<ul> <li>Indexing: Utilize Microsoft's GraphRAG to convert unstructured documents into Parquet files.</li> <li>Data Preprocessing: Learn how to use utility methods provided by TigerGraphX to transform Parquet files into CSV files compatible with TigerGraph.</li> <li>Schema Design: Understand how to design a graph schema for storing your data.</li> <li>Data Loading: Map the CSV files to the graph schema and load them into TigerGraph seamlessly.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you\u2019ve completed the installation and setup steps outlined in the Installation Guide, including:</p> <ul> <li>Setting up Python and TigerGraph. For more details, refer to the Requirements section.</li> <li>Install TigerGraphX along with its development dependencies. For more details, refer to the Development Installation section.</li> </ul>"},{"location":"graphrag/msft_graphrag_1/#utilize-microsoft-graphrag-for-indexing","title":"Utilize Microsoft GraphRAG for Indexing","text":"<p>The indexing process transforms raw documents into structured data using Microsoft\u2019s GraphRAG. Follow these steps to prepare your data:</p>"},{"location":"graphrag/msft_graphrag_1/#data-preparation","title":"Data Preparation","text":""},{"location":"graphrag/msft_graphrag_1/#create-an-input-folder","title":"Create an Input Folder","text":"<p>Create an <code>input</code> folder in the <code>data</code> directory under <code>applications/msft_graphrag</code> to store the documents you want to index. You can specify a different directory by replacing <code>data</code> with your desired path.</p> <pre><code>mkdir -p data/input\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#add-documents-to-the-input-folder","title":"Add Documents to the Input Folder","text":"<p>Copy your documents (e.g., <code>fin.txt</code>) into the <code>data/input</code> folder.</p>"},{"location":"graphrag/msft_graphrag_1/#initialization","title":"Initialization","text":"<p>Initialize the indexing system in the <code>data</code> directory.</p> <pre><code>python3 -m graphrag init --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#set-up-openai-api-key","title":"Set Up OpenAI API Key","text":"<p>GraphRAG requires an OpenAI API key. To configure it:</p> <ol> <li>Open the <code>.env</code> file in the <code>data</code> directory:    <pre><code>vi data/.env\n</code></pre></li> <li>Add your API key:    <pre><code>GRAPHRAG_API_KEY=&lt;Your OpenAI API Key&gt;\n</code></pre></li> </ol>"},{"location":"graphrag/msft_graphrag_1/#optional-switch-to-a-cost-effective-model","title":"Optional: Switch to a Cost-Effective Model","text":"<p>GraphRAG uses the <code>gpt-4-turbo-preview</code> model by default. To reduce costs, switch to the <code>gpt-4o-mini</code> model by editing the <code>settings.yaml</code> file in the <code>data</code> directory:</p> <pre><code>llm:\n  api_key: ${GRAPHRAG_API_KEY}\n  type: openai_chat # or azure_openai_chat\n  model: gpt-4o-mini # Use a cost-effective model\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#indexing","title":"Indexing","text":"<p>Run the indexing process to convert documents into structured data. This step uses LLMs and may take several minutes depending on the dataset size and hardware.</p> <pre><code>python3 -m graphrag index --no-cache --root data\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#utilize-tigergraphx-for-data-preprocessing","title":"Utilize TigerGraphX for Data Preprocessing","text":"<p>Transform the structured Parquet files generated by GraphRAG into CSV files that TigerGraph can import.</p>"},{"location":"graphrag/msft_graphrag_1/#convert-parquet-to-csv","title":"Convert Parquet to CSV","text":"<p>Run the script below to convert Parquet files into TigerGraph-compatible CSV files. You can find the Python script here.</p> <pre><code>python3 data_import/convert_parquet_to_tg_csv.py \\\n--input_dir data/output \\\n--output_dir data/tg_csv\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#transfer-csv-files-to-tigergraph-server","title":"Transfer CSV Files to TigerGraph Server","text":"<p>Transfer the generated CSV files to your TigerGraph server. Use the following command, replacing <code>username</code> and <code>tigergraph-server</code> with your server credentials:</p> <pre><code>scp data/tg_csv/* username@tigergraph-server:/home/tigergraph/data/graphrag\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#create-a-graph","title":"Create a Graph","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>Now, let's define the schema using Python. You can execute the following code in a Python shell or Jupyter Notebook. To access the original <code>.ipynb</code> file, download it from msft_graphrag_1_1.ipynb.</p>"},{"location":"graphrag/msft_graphrag_1/#define-a-graph-schema","title":"Define a Graph Schema","text":"<p>In this example, we will initialize a graph using a schema defined in a YAML file. The schema structure is represented visually in the following image.</p> <p></p> <p>First, convert the YAML file into a graph schema using the <code>GraphSchema.ensure_config</code> method. <pre><code>from tigergraphx import Graph, GraphSchema, LoadingJobConfig, TigerGraphConnectionConfig\nresource_dir = \"../../applications/msft_graphrag/query/resources/\"\nschema_path = resource_dir + \"graph_schema.yaml\"\ngraph_schema=GraphSchema.ensure_config(schema_path)\n</code></pre></p>"},{"location":"graphrag/msft_graphrag_1/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p> <pre><code>connection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#create-a-graph_1","title":"Create a Graph","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p> <pre><code>graph = Graph(\n    graph_schema=graph_schema,\n    tigergraph_connection_config=connection,\n    drop_existing_graph=False,\n)\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#load-data-to-tigergraph","title":"Load Data to TigerGraph","text":"<p>We will load data into the graph using a pre-defined loading job configuration. The configuration is stored in a YAML file.</p> <pre><code>loading_job_path = resource_dir + \"loading_job_config.yaml\"\ngraph.load_data(loading_job_config=LoadingJobConfig.ensure_config(loading_job_path))\n</code></pre>"},{"location":"graphrag/msft_graphrag_1/#next-steps","title":"Next Steps","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 2: Use Jupyter Notebook to explore graph data and perform Graph Analysis.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_1_1/","title":"Msft graphrag 1 1","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph, GraphSchema, LoadingJobConfig, TigerGraphConnectionConfig\nresource_dir = \"../../applications/msft_graphrag/query/resources/\"\nschema_path = resource_dir + \"graph_schema.yaml\"\ngraph_schema=GraphSchema.ensure_config(schema_path)\n</pre> from tigergraphx import Graph, GraphSchema, LoadingJobConfig, TigerGraphConnectionConfig resource_dir = \"../../applications/msft_graphrag/query/resources/\" schema_path = resource_dir + \"graph_schema.yaml\" graph_schema=GraphSchema.ensure_config(schema_path) In\u00a0[2]: Copied! <pre>connection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\n</pre> connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", }) In\u00a0[3]: Copied! <pre>graph = Graph(\n    graph_schema=graph_schema,\n    tigergraph_connection_config=connection,\n    drop_existing_graph=False,\n)\n</pre> graph = Graph(     graph_schema=graph_schema,     tigergraph_connection_config=connection,     drop_existing_graph=False, ) In\u00a0[4]: Copied! <pre>print(graph.number_of_nodes())\n</pre> print(graph.number_of_nodes()) <pre>0\n</pre> <p>After that, we will load data into the graph using a pre-defined loading job configuration. The configuration is stored in a YAML file.</p> In\u00a0[5]: Copied! <pre>loading_job_path = resource_dir + \"loading_job_config.yaml\"\ngraph.load_data(loading_job_config=LoadingJobConfig.ensure_config(loading_job_path))\n</pre> loading_job_path = resource_dir + \"loading_job_config.yaml\" graph.load_data(loading_job_config=LoadingJobConfig.ensure_config(loading_job_path)) <p>Now, let's check the total number of nodes in the graph again. We should observe that some nodes have been successfully loaded into the graph.</p> In\u00a0[6]: Copied! <pre>print(graph.number_of_nodes())\n</pre> print(graph.number_of_nodes()) <pre>931\n</pre>"},{"location":"graphrag/msft_graphrag_1_1/#create-a-graph","title":"Create a Graph\u00b6","text":""},{"location":"graphrag/msft_graphrag_1_1/#define-a-graph-schema","title":"Define a Graph Schema\u00b6","text":"<p>TigerGraph is a schema-based database, which requires defining a schema to structure your graph. This schema specifies the graph name, nodes (vertices), edges (relationships), and their respective attributes.</p> <p>In this example, we will initialize a graph using a schema defined in a YAML file.</p> <p>First, convert the YAML file into a graph schema using the <code>GraphSchema.ensure_config</code> method.</p>"},{"location":"graphrag/msft_graphrag_1_1/#define-the-tigergraph-connection-configuration","title":"Define the TigerGraph Connection Configuration\u00b6","text":"<p>In addition to defining the schema, a connection configuration is necessary to establish communication with the TigerGraph server.</p>"},{"location":"graphrag/msft_graphrag_1_1/#create-a-graph","title":"Create a Graph\u00b6","text":"<p>Running the following command will create a graph using the user-defined schema if it does not already exist. If the graph exists, the command will return the existing graph. To overwrite the existing graph, set the drop_existing_graph parameter to True. Note that creating the graph may take several seconds.</p>"},{"location":"graphrag/msft_graphrag_1_1/#load-data","title":"Load Data\u00b6","text":"<p>First, let's check the total number of nodes in the graph. As anticipated, the graph is currently empty.</p>"},{"location":"graphrag/msft_graphrag_2/","title":"Supporting Microsoft's GraphRAG: Part 2","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph, TigerGraphConnectionConfig\nconnection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph, TigerGraphConnectionConfig connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", }) G = Graph.from_db(\"GraphRAG\", connection) In\u00a0[2]: Copied! <pre>schema = G.get_schema()\nschema[\"graph_name\"]\n</pre> schema = G.get_schema() schema[\"graph_name\"] Out[2]: <pre>'GraphRAG'</pre> In\u00a0[3]: Copied! <pre>for node in schema[\"nodes\"].items():\n    print(node)\n</pre> for node in schema[\"nodes\"].items():     print(node) <pre>('Document', {'primary_key': 'id', 'attributes': {'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('TextUnit', {'primary_key': 'id', 'attributes': {'text': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'n_tokens': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('Entity', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'name': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'entity_type': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('Relationship', {'primary_key': 'id', 'attributes': {'human_readable_id': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'weight': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'description': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n('Community', {'primary_key': 'id', 'attributes': {'level': {'data_type': &lt;DataType.UINT: 'UINT'&gt;, 'default_value': None}, 'rank': {'data_type': &lt;DataType.DOUBLE: 'DOUBLE'&gt;, 'default_value': None}, 'rank_explanation': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'title': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'full_content': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'summary': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}, 'id': {'data_type': &lt;DataType.STRING: 'STRING'&gt;, 'default_value': None}}})\n</pre> In\u00a0[4]: Copied! <pre>for edge in schema[\"edges\"].items():\n    print(edge)\n</pre> for edge in schema[\"edges\"].items():     print(edge) <pre>('document_contains_text_unit', {'is_directed_edge': False, 'from_node_type': 'Document', 'to_node_type': 'TextUnit', 'attributes': {}})\n('text_unit_contains_entity', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Entity', 'attributes': {}})\n('text_unit_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'TextUnit', 'to_node_type': 'Relationship', 'attributes': {}})\n('relationship_source', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'attributes': {}})\n('relationship_target', {'is_directed_edge': False, 'from_node_type': 'Relationship', 'to_node_type': 'Entity', 'attributes': {}})\n('community_contains_entity', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Entity', 'attributes': {}})\n('community_contains_relationship', {'is_directed_edge': False, 'from_node_type': 'Community', 'to_node_type': 'Relationship', 'attributes': {}})\n</pre> In\u00a0[5]: Copied! <pre>G.number_of_nodes()\n</pre> G.number_of_nodes() Out[5]: <pre>931</pre> In\u00a0[6]: Copied! <pre>for node_type in schema[\"nodes\"]:\n    print(f\"{node_type}: {G.number_of_nodes(node_type)}\")\n</pre> for node_type in schema[\"nodes\"]:     print(f\"{node_type}: {G.number_of_nodes(node_type)}\") <pre>Document: 1\nTextUnit: 47\nEntity: 398\nRelationship: 426\nCommunity: 59\n</pre> In\u00a0[7]: Copied! <pre>G.number_of_edges()\n</pre> G.number_of_edges() Out[7]: <pre>3630</pre> In\u00a0[8]: Copied! <pre>for edge_type in schema[\"edges\"]:\n    print(f\"{edge_type}: {G.number_of_edges(edge_type)}\")\n</pre> for edge_type in schema[\"edges\"]:     print(f\"{edge_type}: {G.number_of_edges(edge_type)}\") <pre>document_contains_text_unit: 47\ntext_unit_contains_entity: 699\ntext_unit_contains_relationship: 517\nrelationship_source: 426\nrelationship_target: 426\ncommunity_contains_entity: 566\ncommunity_contains_relationship: 949\n</pre> In\u00a0[9]: Copied! <pre>G.get_nodes(node_type=\"Entity\", limit=2)\n</pre> G.get_nodes(node_type=\"Entity\", limit=2) Out[9]: v_id v_type human_readable_id entity_type name description id 0 7b7427c9d4a943f09fe17738ebb6cfe6 Entity 72 EVENT MRSA Methicillin-resistant Staphylococcus aureus, a... 7b7427c9d4a943f09fe17738ebb6cfe6 1 7150e8aec7644dd99d509dac200f138d Entity 65 ORGANIZATION UNIVERSAL PLASMA A project receiving funding from the Defense H... 7150e8aec7644dd99d509dac200f138d In\u00a0[10]: Copied! <pre>G.get_nodes(node_type=\"Relationship\", limit=2)\n</pre> G.get_nodes(node_type=\"Relationship\", limit=2) Out[10]: v_id v_type human_readable_id rank weight description id 0 15094f91ea714506b61c8c3ca36e5a79 Relationship 163 34 5 Germany is one of the countries where CytoSorb... 15094f91ea714506b61c8c3ca36e5a79 1 11297fa63c784e4db7c37c532c09bd59 Relationship 229 7 1 U.S. Air Force Materiel Command, part of the U... 11297fa63c784e4db7c37c532c09bd59 In\u00a0[11]: Copied! <pre>G.get_nodes(node_type=\"Community\", limit=2)\n</pre> G.get_nodes(node_type=\"Community\", limit=2) Out[11]: v_id v_type summary level full_content rank id rank_explanation title 0 56 Community The community centers around the EUPHRATES tri... 1 # EUPHRATES Trial and Its Expansions\\n\\nThe co... 6.5 56 The impact severity rating is moderately high ... Community 56 1 14 Community This report focuses on the interconnected role... 0 # CytoSorb and ARDS in the Context of COVID-19... 8.5 14 The high impact severity rating reflects the c... Community 14"},{"location":"graphrag/msft_graphrag_2/#supporting-microsofts-graphrag-part-2","title":"Supporting Microsoft\u2019s GraphRAG: Part 2\u00b6","text":"<p>In the previous section, we utilized Microsoft's GraphRAG to transform unstructured documents into Parquet files. Using TigerGraphX, we then converted these files into CSV format, created a graph in TigerGraph, and loaded the CSV data into it.</p> <p>Now, let\u2019s use Jupyter Notebook to explore the graph data and perform graph analysis.</p> <p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_2.ipynb.</p>"},{"location":"graphrag/msft_graphrag_2/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":"<p>Since the graph has already been created in TigerGraph, redefining its schema is unnecessary. Instead, you can provide the graph name to retrieve it. TigerGraphX will verify if the graph exists in TigerGraph and, if it does, will return the corresponding graph.</p>"},{"location":"graphrag/msft_graphrag_2/#display-the-graph-schema","title":"Display the Graph Schema\u00b6","text":"<p>Let's retrieve the graph schema using the <code>get_schema</code> method. The output is a Python dictionary containing three keys: <code>\"graph_name\"</code>, <code>\"nodes\"</code>, and <code>\"edges\"</code>. We'll print each of them individually to explore the schema details.</p>"},{"location":"graphrag/msft_graphrag_2/#retrieve-the-graph-schema-and-display-the-graph-name","title":"Retrieve the Graph Schema and Display the Graph Name\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-node-tyeps","title":"Display the Node Tyeps\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-edge-types","title":"Display the Edge Types\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-node-and-edge-counts","title":"Display Node and Edge Counts\u00b6","text":"<p>Gain deeper insights into the graph by exploring details such as the total number of nodes and the count of nodes for each node type.</p>"},{"location":"graphrag/msft_graphrag_2/#display-the-total-number-of-nodes","title":"Display the Total Number of Nodes\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-count-of-nodes-for-each-node-type","title":"Display the Count of Nodes for Each Node Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-total-number-of-edges","title":"Display the Total Number of Edges\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#display-the-count-of-edges-for-each-edge-type","title":"Display the Count of Edges for Each Edge Type\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#retrieve-sample-nodes-from-the-graph","title":"Retrieve Sample Nodes from the Graph\u00b6","text":""},{"location":"graphrag/msft_graphrag_2/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>Supporting Microsoft\u2019s GraphRAG: Part 3: Perform queries using GSQL and Python-native TigerGraphX, with global and local context builders.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"graphrag/msft_graphrag_3/","title":"Supporting Microsoft's GraphRAG: Part 3","text":"In\u00a0[1]: Copied! <pre>from tigergraphx import Graph, TigerGraphConnectionConfig\nconnection = TigerGraphConnectionConfig.ensure_config({\n    \"host\": \"http://127.0.0.1\",\n    \"username\": \"tigergraph\",\n    \"password\": \"tigergraph\",\n})\nG = Graph.from_db(\"GraphRAG\", connection)\n</pre> from tigergraphx import Graph, TigerGraphConnectionConfig connection = TigerGraphConnectionConfig.ensure_config({     \"host\": \"http://127.0.0.1\",     \"username\": \"tigergraph\",     \"password\": \"tigergraph\", }) G = Graph.from_db(\"GraphRAG\", connection) In\u00a0[2]: Copied! <pre>G.get_nodes(\n    node_type=\"Entity\",\n    return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],\n    limit=2,\n)\n</pre> G.get_nodes(     node_type=\"Entity\",     return_attributes=[\"id\", \"name\", \"entity_type\", \"description\"],     limit=2, ) Out[2]: id name entity_type description 0 7b7427c9d4a943f09fe17738ebb6cfe6 MRSA EVENT Methicillin-resistant Staphylococcus aureus, a... 1 7150e8aec7644dd99d509dac200f138d UNIVERSAL PLASMA ORGANIZATION A project receiving funding from the Defense H... In\u00a0[3]: Copied! <pre>start_nodes = [\"7373c84a439841d580b4650dac71136f\", \"4a5ddbde3f354a79bb5ae3436ab67d25\"]\nG.get_neighbors(\n    start_nodes=start_nodes,\n    start_node_type=\"Entity\",\n    edge_types=\"community_contains_entity\",\n    return_attributes=[\"id\", \"title\", \"full_content\"],\n)\n</pre> start_nodes = [\"7373c84a439841d580b4650dac71136f\", \"4a5ddbde3f354a79bb5ae3436ab67d25\"] G.get_neighbors(     start_nodes=start_nodes,     start_node_type=\"Entity\",     edge_types=\"community_contains_entity\",     return_attributes=[\"id\", \"title\", \"full_content\"], ) Out[3]: id title full_content 0 10 Community 10 # Innovations in Preventing Contrast-Induced N... 1 1 Community 1 # CytoSorb and Its Global Healthcare Impact\\n\\... 2 30 Community 30 # CytoSorb and Global Healthcare Impact\\n\\nThi... In\u00a0[4]: Copied! <pre>import tiktoken\nfrom typing import Optional, List\nfrom tigergraphx.graphrag import BaseContextBuilder\nfrom tigergraphx.core import Graph\nclass GlobalContextBuilder(BaseContextBuilder):\n    def __init__(\n        self,\n        graph: Graph,\n        token_encoder: Optional[tiktoken.Encoding] = None,\n    ):\n        \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"\n        super().__init__(\n            graph=graph,\n            single_batch=False,\n            token_encoder=token_encoder,\n        )\n    async def build_context(self) -&gt; str | List[str]:\n        \"\"\"Build local context.\"\"\"\n        context: List[str] = []\n        config = {\n            \"max_tokens\": 12000,\n            \"section_name\": \"Communities\",\n            \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],\n            \"limit\": 1000,\n        }\n        df = self.graph.get_nodes(\n            node_type=\"Community\",\n            return_attributes=config[\"return_attributes\"],\n            limit=config[\"limit\"],\n        )\n        if df is not None:\n            text_context = self.batch_and_convert_to_text(\n                graph_data=df,\n                max_tokens=config[\"max_tokens\"],\n                single_batch=self.single_batch,\n                section_name=config[\"section_name\"],\n            )\n            context.extend(\n                text_context if isinstance(text_context, list) else [text_context]\n            )\n        return context\n</pre> import tiktoken from typing import Optional, List from tigergraphx.graphrag import BaseContextBuilder from tigergraphx.core import Graph class GlobalContextBuilder(BaseContextBuilder):     def __init__(         self,         graph: Graph,         token_encoder: Optional[tiktoken.Encoding] = None,     ):         \"\"\"Initialize LocalContextBuilder with graph config and token encoder.\"\"\"         super().__init__(             graph=graph,             single_batch=False,             token_encoder=token_encoder,         )     async def build_context(self) -&gt; str | List[str]:         \"\"\"Build local context.\"\"\"         context: List[str] = []         config = {             \"max_tokens\": 12000,             \"section_name\": \"Communities\",             \"return_attributes\": [\"id\", \"rank\", \"title\", \"full_content\"],             \"limit\": 1000,         }         df = self.graph.get_nodes(             node_type=\"Community\",             return_attributes=config[\"return_attributes\"],             limit=config[\"limit\"],         )         if df is not None:             text_context = self.batch_and_convert_to_text(                 graph_data=df,                 max_tokens=config[\"max_tokens\"],                 single_batch=self.single_batch,                 section_name=config[\"section_name\"],             )             context.extend(                 text_context if isinstance(text_context, list) else [text_context]             )         return context <p>Here\u2019s how you can utilize the custom global context builder:</p> In\u00a0[5]: Copied! <pre>global_context_builder = GlobalContextBuilder(G)\ncontext_list = await global_context_builder.build_context()\n# Print the first 1000 characters for easier visualization of long text\nprint(context_list[0][:1000])\n</pre> global_context_builder = GlobalContextBuilder(G) context_list = await global_context_builder.build_context() # Print the first 1000 characters for easier visualization of long text print(context_list[0][:1000]) <pre>-----Communities-----\nid|rank|title|full_content\n33|8.5|Community 33|# CytoSorb and Cytokine Storm Management in Brain Dead Organ Donors\\n\\nThis report focuses on the application of CytoSorb technology by CytoSorbents in managing cytokine storms, particularly in the context of brain dead organ donors. The relationship between cytokine storms and the viability of organs for transplantation highlights a critical area of medical intervention.\\n\\n## CytoSorb's role in cytokine storm management\\n\\nCytoSorb is utilized in clinical situations characterized by elevated cytokine levels, including cytokine storms, which are critical conditions that can lead to multiple organ failure. The technology's application to cytokine storm management represents a significant advancement in treating conditions that result in high cytokine levels. This is particularly relevant in the context of brain dead organ donors, where cytokine storms can reduce the viability of organs for transplantation. [Data: Rela\n</pre>"},{"location":"graphrag/msft_graphrag_3/#supporting-microsofts-graphrag-part-3","title":"Supporting Microsoft\u2019s GraphRAG: Part 3\u00b6","text":"<p>To run this Jupyter Notebook, you can download the original <code>.ipynb</code> file from msft_graphrag_3.ipynb.</p>"},{"location":"graphrag/msft_graphrag_3/#get-the-graph-from-tigergraph","title":"Get the Graph from TigerGraph\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#hybrid-retrieval","title":"Hybrid Retrieval\u00b6","text":"<p>TigerGraph offers two flexible ways to perform hybrid retrieval, allowing you to extract relevant graph and vector data efficiently for GraphRAG workflows.</p>"},{"location":"graphrag/msft_graphrag_3/#using-tigergraphx","title":"Using TigerGraphX\u00b6","text":"<p>TigerGraphX offers an intuitive, Python-native interface for hybrid retrieval, ideal for developers seeking simplicity and ease of use.</p> <p>Key Advantage: Minimal learning curve with high-level Python APIs, seamlessly integrated with existing workflows.</p> <p>Below are some illustrative examples.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-nodes-with-specific-attributes","title":"Retrieve Nodes with Specific Attributes\u00b6","text":"<p>You can use the following code to fetch up to two nodes of type \"Entity\" and display their \"id,\" \"entity_type,\" and \"description\" attributes.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-neighbors-with-specific-attributes","title":"Retrieve Neighbors with Specific Attributes\u00b6","text":"<p>The following code demonstrates how to fetch neighbors of specific nodes. In this example, the query retrieves neighbors connected to the given <code>start_nodes</code> of type <code>\"Entity\"</code> through the edge type <code>\"community_contains_entity\"</code>. The attributes <code>\"id\"</code>, <code>\"title\"</code>, and <code>\"full_content\"</code> of the neighbors are returned.</p>"},{"location":"graphrag/msft_graphrag_3/#retrieve-top-k-using-tigervectors-vector-search-capability-planned-feature","title":"Retrieve Top-K Using TigerVector's Vector Search Capability [Planned Feature]\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#using-gsql","title":"Using GSQL\u00b6","text":"<p>For developers seeking fine-grained control or complex retrieval logic, GSQL offers unmatched flexibility. As TigerGraph's built-in query language, GSQL empowers you to perform advanced graph data analysis. For more details, see the official documentation.</p> <p>Key Advantage: Supports complex logic, customization, and direct interaction with TigerGraph\u2019s powerful query engine.</p> <ol> <li>Use an LLM to convert the query into an embedding.</li> <li>Write a GSQL query to retrieve the top-K similar objects and their neighbors, combining structured and vector-based retrieval:</li> </ol> <pre>CREATE OR REPLACE QUERY query (List&lt;float&gt; embedding, int k) {\n  Nodes = TopKVectorSearch({Entity.entity_embedding}, embedding, k);\n\n  Neighbors =\n    SELECT t\n    FROM Nodes:s -(community_contains_entity:e)- :t;\n\n  PRINT Neighbors[Neighbors.id, Neighbors.title, Neighbors.full_content];\n}\n</pre>"},{"location":"graphrag/msft_graphrag_3/#context-building-writing-custom-context-builders","title":"Context Building: Writing Custom Context Builders\u00b6","text":"<p>Context builders play a vital role in graph-powered RAG workflows. They transform retrieved graph data into structured, meaningful contexts for tasks such as interactions with LLMs).</p> <p>TigerGraphX simplifies this process by offering the flexible <code>BaseContextBuilder</code> class, which allows developers to define custom logic for context building.</p>"},{"location":"graphrag/msft_graphrag_3/#key-features-of-basecontextbuilder","title":"Key Features of <code>BaseContextBuilder</code>\u00b6","text":"<p>The <code>BaseContextBuilder</code> class in TigerGraphX provides a strong foundation for creating custom context builders, offering:</p> <ul> <li>Core Abstraction: A reusable framework for building context logic.</li> <li>Customizable Design: Extensibility for implementing both global and query-specific context generation.</li> </ul>"},{"location":"graphrag/msft_graphrag_3/#key-components","title":"Key Components\u00b6","text":"<ol> <li><p>Abstract Method - <code>build_context</code>: Subclasses must implement this method to define the logic for constructing context.</p> <pre>@abstractmethod\nasync def build_context(self, *args, **kwargs) -&gt; str | List[str]:\n    \"\"\"Abstract method to build context.\"\"\"\n    pass\n</pre> </li> <li><p>Batching and Retrieval Methods:</p> <ul> <li><code>batch_and_convert_to_text</code>: Formats graph data into token-aware text.</li> <li><code>retrieve_top_k_objects</code>: Efficiently retrieves top-K objects for query-based context.</li> </ul> </li> </ol>"},{"location":"graphrag/msft_graphrag_3/#example-global-context-builder","title":"Example: Global Context Builder\u00b6","text":""},{"location":"graphrag/msft_graphrag_3/#example-local-context-builder","title":"Example: Local Context Builder\u00b6","text":"<p>To understand the functionality of the <code>LocalContextBuilder</code> class, let's review the key code from its <code>build_context</code> method.</p> <p></p> <pre><code># Retrieve top-k objects\ntop_k_objects: List[str] = await self.retrieve_top_k_objects(query, k=k)\n...\n# Iterate over different neighbor types\nfor neighbor in neighbor_types:\n    df = self.graph.get_neighbors(...)\n    if df is not None:\n        text_context = self.batch_and_convert_to_text(...)\n        context.extend(\n            text_context if isinstance(text_context, list) else [text_context]\n        )\nreturn \"\\n\\n\".join(context)\n</code></pre> <p>For full implementations of different context builders, refer to the following links:</p> <ul> <li>LocalContextBuilder Code</li> </ul> <p>Here\u2019s how you can utilize the custom local context builder:</p> <pre>local_builder = LocalContextBuilder(graph=graph, search_engine=search_engine)\nlocal_context = await local_builder.build_context(query=\"What are the main topics discussed in the article?\")\n</pre>"},{"location":"graphrag/msft_graphrag_3/#integrate-with-llm","title":"Integrate with LLM\u00b6","text":"<p>After successfully building context from TigerGraph, the final step is integrating it with LLMs, including chat models and embedding models.</p> <p>We have provided an example implementation, which you can find here: Example Code.</p>"},{"location":"graphrag/msft_graphrag_3/#workflow-overview","title":"Workflow Overview\u00b6","text":"<p>The integration process follows the workflow illustrated below:</p> <p></p>"},{"location":"graphrag/msft_graphrag_3/#whats-next","title":"What\u2019s Next?\u00b6","text":"<ul> <li>API Reference: Dive deeper into TigerGraphX APIs.</li> </ul> <p>Start transforming your GraphRAG workflows with the power of TigerGraphX today!</p>"},{"location":"reference/features_overview/","title":"Features Overview","text":"<p>TigerGraphX is designed to simplify complex workflows involving graph databases, vector search, and large language models (LLMs). This page provides an overview of the key features of TigerGraphX and serves as a roadmap to the detailed API documentation for each functionality.</p>"},{"location":"reference/features_overview/#1-schema-management-graph-db","title":"1. Schema Management (Graph DB)","text":"<p>TigerGraphX provides intuitive, Python-native APIs for defining and managing graph schemas. This feature includes:</p> <ul> <li>Programmatic creation and modification of vertices and edges.</li> <li>Support for attributes, primary keys, and schema constraints.</li> <li>Compatibility with YAML and JSON schema definitions.</li> </ul>"},{"location":"reference/features_overview/#2-data-loading-management-graph-db","title":"2. Data Loading Management (Graph DB)","text":"<p>Efficiently load data into TigerGraph from a variety of sources. Key capabilities include:</p> <ul> <li>Support for Parquet and CSV files for high-efficiency workflows.</li> <li>Automated loading jobs to streamline the data import process.</li> <li>Data transformation utilities for pre-processing and compatibility.</li> </ul>"},{"location":"reference/features_overview/#3-graph-library-interface-graph-db-graph-query-language","title":"3. Graph Library Interface (Graph DB, Graph Query Language)","text":"<p>Perform common graph operations using Python-native APIs, including:</p> <ul> <li>CRUD operations for vertices and edges.</li> <li>Multi-hop traversals to analyze relationships in the graph.</li> <li>Graph reporting for insights and analysis.</li> </ul>"},{"location":"reference/features_overview/#4-graph-query-interface-graph-db-graph-query-language","title":"4. Graph Query Interface (Graph DB, Graph Query Language)","text":"<p>Execute advanced queries on your TigerGraph database with ease. This feature includes:</p> <ul> <li>Simplified query execution with Python-based methods.</li> <li>Query results formatted as Pandas DataFrames for seamless integration with analytics workflows.</li> </ul>"},{"location":"reference/features_overview/#5-vector-search-capabilities-vector-db","title":"5. Vector Search Capabilities (Vector DB)","text":"<p>Enhance AI-driven applications with vector embedding support. Key functionalities include:</p> <ul> <li>Storing and querying vector embeddings alongside graph data.</li> <li>Top-K similarity searches for retrieving the most relevant entities.</li> <li>Hybrid retrieval workflows combining graph traversal and vector search.</li> </ul>"},{"location":"reference/features_overview/#6-llm-integration-and-support-llm","title":"6. LLM Integration and Support (LLM)","text":"<p>Enable advanced applications by integrating graph data with large language models (LLMs). Key features:</p> <ul> <li>Token-aware context building for LLM workflows.</li> <li>Hybrid retrieval combining graph, semantic, and vector-based searches.</li> <li>Direct API integration with LLM platforms like OpenAI.</li> </ul>"},{"location":"reference/features_overview/#7-configuration-management-graph-db-vector-db-llm","title":"7. Configuration Management (Graph DB, Vector DB, LLM)","text":"<p>Simplify configuration for various integrations and workflows:</p> <ul> <li>Manage graph database settings programmatically.</li> <li>Configure vector search parameters for efficient retrieval.</li> <li>Customize LLM settings for seamless API interaction.</li> </ul>"},{"location":"reference/features_overview/#8-graphrag-support-graph-db-vector-db-llm","title":"8. GraphRAG Support (Graph DB, Vector DB, LLM)","text":"<p>TigerGraphX simplifies Graph-Retrieval Augmented Generation (GraphRAG) workflows. This feature includes:</p> <ul> <li>Schema definition and data preparation for GraphRAG.</li> <li>Hybrid retrieval methods optimized for GraphRAG use cases.</li> <li>Python-native APIs for context building and LLM integration.</li> </ul>"},{"location":"reference/features_overview/#next-steps","title":"Next Steps","text":"<p>To dive deeper into TigerGraphX\u2019s features, explore the detailed API documentation for each section. Start building powerful graph applications today!</p>"},{"location":"reference/01_core/digraph/","title":"DiGraph","text":""},{"location":"reference/01_core/digraph/#tigergraphx.core.graph.DiGraph","title":"<code>DiGraph</code>","text":"<p>               Bases: <code>HomoGraph</code></p> <p>Represents a directed graph with a single node and edge type.</p>"},{"location":"reference/01_core/digraph/#tigergraphx.core.graph.DiGraph.__init__","title":"<code>__init__(graph_name, node_type='MyNode', edge_type='MyEdge', node_primary_key='id', node_attributes={'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}, edge_attributes={'weight': 'DOUBLE', 'description': 'STRING'}, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize a DiGraph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>'MyNode'</code> )           \u2013            <p>The type of nodes in the graph. Defaults to \"MyNode\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>'MyEdge'</code> )           \u2013            <p>The type of edges in the graph. Defaults to \"MyEdge\".</p> </li> <li> <code>node_primary_key</code>               (<code>str</code>, default:                   <code>'id'</code> )           \u2013            <p>The primary key for nodes. Defaults to \"id\".</p> </li> <li> <code>node_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for nodes. Defaults to: {     \"id\": \"STRING\",     \"entity_type\": \"STRING\",     \"description\": \"STRING\", }</p> </li> <li> <code>edge_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'weight': 'DOUBLE', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for edges. Defaults to: {     \"weight\": \"DOUBLE\",     \"description\": \"STRING\", }</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for TigerGraph connection. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph if it exists. Defaults to False.</p> </li> </ul>"},{"location":"reference/01_core/graph/","title":"Graph","text":""},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph","title":"<code>Graph</code>","text":"<p>Represents a graph structure supporting both homogeneous and heterogeneous graphs.</p> <p>This class handles:</p> <ul> <li>Undirected Homogeneous Graphs</li> <li>Directed Homogeneous Graphs</li> <li>Heterogeneous Graphs with multiple node and edge types</li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.__init__","title":"<code>__init__(graph_schema, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize the Graph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_schema</code>               (<code>GraphSchema</code>)           \u2013            <p>The schema of the graph.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for TigerGraph connection. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph if it exists.  Defaults to False.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.add_node","title":"<code>add_node(node_id, node_type='', **attr)</code>","text":"<p>Add a node to the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> <li> <code>**attr</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional attributes for the node.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.remove_node","title":"<code>remove_node(node_id, node_type='')</code>","text":"<p>Remove a node from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node was removed, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.has_node","title":"<code>has_node(node_id, node_type='')</code>","text":"<p>Check if a node exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_node_data","title":"<code>get_node_data(node_id, node_type='')</code>","text":"<p>Get data of a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The node data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_node_edges","title":"<code>get_node_edges(node_id, node_type='', edge_types=[], num_edge_samples=1000)</code>","text":"<p>Get edges connected to a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> <li> <code>edge_types</code>               (<code>List | str</code>, default:                   <code>[]</code> )           \u2013            <p>Types of edges to include. Defaults to [].</p> </li> <li> <code>num_edge_samples</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of edge samples to retrieve. Defaults to 1000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List</code> (              <code>List</code> )          \u2013            <p>A list of edges.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.add_edge","title":"<code>add_edge(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='', **attr)</code>","text":"<p>Add an edge to the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type. Defaults to \"\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of the edge. Defaults to \"\".</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type. Defaults to \"\".</p> </li> <li> <code>**attr</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional attributes for the edge.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.has_edge","title":"<code>has_edge(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='')</code>","text":"<p>Check if an edge exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type. Defaults to \"\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of the edge. Defaults to \"\".</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the edge exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_edge_data","title":"<code>get_edge_data(src_node_id, tgt_node_id, src_node_type='', edge_type='', tgt_node_type='')</code>","text":"<p>Get data of a specific edge.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>src_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source node type. Defaults to \"\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of the edge. Defaults to \"\".</p> </li> <li> <code>tgt_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Target node type. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The edge data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.degree","title":"<code>degree(node_id, node_type='', edge_types=[])</code>","text":"<p>Get the degree of a node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of the node. Defaults to \"\".</p> </li> <li> <code>edge_types</code>               (<code>List</code>, default:                   <code>[]</code> )           \u2013            <p>Types of edges to consider. Defaults to [].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The degree of the node.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.number_of_nodes","title":"<code>number_of_nodes(node_type=None)</code>","text":"<p>Get the number of nodes in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of nodes to count. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of nodes.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.number_of_edges","title":"<code>number_of_edges(edge_type=None)</code>","text":"<p>Get the number of edges in the graph.</p> <p>Parameters:</p> <ul> <li> <code>edge_type</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The type of edges to count. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of edges.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_nodes","title":"<code>get_nodes(node_type='', filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Retrieve nodes from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The type of nodes to retrieve. Defaults to \"\".</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Limit the number of results. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of nodes or None.</p> </li> </ul>"},{"location":"reference/01_core/graph/#tigergraphx.core.graph.Graph.get_neighbors","title":"<code>get_neighbors(start_nodes, start_node_type='', edge_types=None, target_node_types=None, filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Get neighbors of specified nodes.</p> <p>Parameters:</p> <ul> <li> <code>start_nodes</code>               (<code>str | List[str]</code>)           \u2013            <p>Starting node(s).</p> </li> <li> <code>start_node_type</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Type of starting nodes. Defaults to \"\".</p> </li> <li> <code>edge_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of edges to consider. Defaults to None.</p> </li> <li> <code>target_node_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of target nodes. Defaults to None.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of neighbors to retrieve. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of neighbors or None.</p> </li> </ul>"},{"location":"reference/01_core/homograph/","title":"HomoGraph","text":""},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph","title":"<code>HomoGraph</code>","text":"<p>Represents a homogeneous graph with a single node and edge type.</p>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.__init__","title":"<code>__init__(graph_name, node_type, node_schema, edge_type, edge_schema, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize a HomoGraph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>node_type</code>               (<code>str</code>)           \u2013            <p>The type of nodes in the graph.</p> </li> <li> <code>node_schema</code>               (<code>NodeSchema</code>)           \u2013            <p>The schema for the nodes.</p> </li> <li> <code>edge_type</code>               (<code>str</code>)           \u2013            <p>The type of edges in the graph.</p> </li> <li> <code>edge_schema</code>               (<code>EdgeSchema</code>)           \u2013            <p>The schema for the edges.</p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for TigerGraph connection. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph if it exists. Defaults to False.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.add_node","title":"<code>add_node(node_id, **attr)</code>","text":"<p>Add a node to the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>**attr</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional attributes for the node.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.remove_node","title":"<code>remove_node(node_id)</code>","text":"<p>Remove a node from the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node was removed, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.has_node","title":"<code>has_node(node_id)</code>","text":"<p>Check if a node exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the node exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_node_data","title":"<code>get_node_data(node_id)</code>","text":"<p>Retrieve data of a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The node data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_node_edges","title":"<code>get_node_edges(node_id, num_edge_samples=1000)</code>","text":"<p>Get edges connected to a specific node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> <li> <code>num_edge_samples</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of edge samples to retrieve. Defaults to 1000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List</code> (              <code>List</code> )          \u2013            <p>A list of edges as tuples.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.add_edge","title":"<code>add_edge(src_node_id, tgt_node_id, **attr)</code>","text":"<p>Add an edge to the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> <li> <code>**attr</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional attributes for the edge.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.has_edge","title":"<code>has_edge(src_node_id, tgt_node_id)</code>","text":"<p>Check if an edge exists in the graph.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str | int</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str | int</code>)           \u2013            <p>Target node identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the edge exists, False otherwise.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_edge_data","title":"<code>get_edge_data(src_node_id, tgt_node_id)</code>","text":"<p>Retrieve data of a specific edge.</p> <p>Parameters:</p> <ul> <li> <code>src_node_id</code>               (<code>str</code>)           \u2013            <p>Source node identifier.</p> </li> <li> <code>tgt_node_id</code>               (<code>str</code>)           \u2013            <p>Target node identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict | None</code>           \u2013            <p>Dict | None: The edge data or None if not found.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.degree","title":"<code>degree(node_id)</code>","text":"<p>Get the degree of a node.</p> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The degree of the node.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.number_of_nodes","title":"<code>number_of_nodes()</code>","text":"<p>Get the total number of nodes in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of nodes.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.number_of_edges","title":"<code>number_of_edges()</code>","text":"<p>Get the total number of edges in the graph.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of edges.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_nodes","title":"<code>get_nodes(filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Retrieve nodes from the graph.</p> <p>Parameters:</p> <ul> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression to apply. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of nodes to retrieve. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of nodes or None.</p> </li> </ul>"},{"location":"reference/01_core/homograph/#tigergraphx.core.graph.HomoGraph.get_neighbors","title":"<code>get_neighbors(start_nodes, edge_types=None, target_node_types=None, filter_expression=None, return_attributes=None, limit=None)</code>","text":"<p>Get neighbors of specified nodes.</p> <p>Parameters:</p> <ul> <li> <code>start_nodes</code>               (<code>str | List[str]</code>)           \u2013            <p>Starting node(s).</p> </li> <li> <code>edge_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of edges to consider. Defaults to None.</p> </li> <li> <code>target_node_types</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Types of target nodes. Defaults to None.</p> </li> <li> <code>filter_expression</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filter expression to apply. Defaults to None.</p> </li> <li> <code>return_attributes</code>               (<code>Optional[str | List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Attributes to return. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of neighbors to retrieve. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pd.DataFrame | None: DataFrame of neighbors or None.</p> </li> </ul>"},{"location":"reference/01_core/nodeview/","title":"NodeView","text":""},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView","title":"<code>NodeView</code>","text":""},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve specific node data. - For homogeneous graphs: key is <code>node_id</code>. - For heterogeneous graphs: key is <code>(node_type, node_id)</code>.</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a node exists.</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all nodes. For homogeneous: return node_id. For heterogeneous: return (node_type, node_id).</p>"},{"location":"reference/01_core/nodeview/#tigergraphx.core.view.NodeView.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of nodes.</p>"},{"location":"reference/01_core/undigraph/","title":"UndiGraph","text":""},{"location":"reference/01_core/undigraph/#tigergraphx.core.graph.UndiGraph","title":"<code>UndiGraph</code>","text":"<p>               Bases: <code>HomoGraph</code></p> <p>Represents an undirected graph with a single node and edge type.</p>"},{"location":"reference/01_core/undigraph/#tigergraphx.core.graph.UndiGraph.__init__","title":"<code>__init__(graph_name, node_type='MyNode', edge_type='MyEdge', node_primary_key='id', node_attributes={'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}, edge_attributes={'weight': 'DOUBLE', 'description': 'STRING'}, tigergraph_connection_config=None, drop_existing_graph=False)</code>","text":"<p>Initialize an UndiGraph instance.</p> <p>Parameters:</p> <ul> <li> <code>graph_name</code>               (<code>str</code>)           \u2013            <p>The name of the graph.</p> </li> <li> <code>node_type</code>               (<code>str</code>, default:                   <code>'MyNode'</code> )           \u2013            <p>The type of nodes in the graph. Defaults to \"MyNode\".</p> </li> <li> <code>edge_type</code>               (<code>str</code>, default:                   <code>'MyEdge'</code> )           \u2013            <p>The type of edges in the graph. Defaults to \"MyEdge\".</p> </li> <li> <code>node_primary_key</code>               (<code>str</code>, default:                   <code>'id'</code> )           \u2013            <p>The primary key for nodes. Defaults to \"id\".</p> </li> <li> <code>node_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'id': 'STRING', 'entity_type': 'STRING', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for nodes. Defaults to: <pre><code>{\n    \"id\": \"STRING\",\n    \"entity_type\": \"STRING\",\n    \"description\": \"STRING\",\n}\n</code></pre></p> </li> <li> <code>edge_attributes</code>               (<code>AttributesType</code>, default:                   <code>{'weight': 'DOUBLE', 'description': 'STRING'}</code> )           \u2013            <p>Attributes for edges. Defaults to: <pre><code>{\n    \"weight\": \"DOUBLE\",\n    \"description\": \"STRING\",\n}\n</code></pre></p> </li> <li> <code>tigergraph_connection_config</code>               (<code>Optional[TigerGraphConnectionConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for TigerGraph connection. Defaults to None.</p> </li> <li> <code>drop_existing_graph</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to drop the existing graph if it exists. Defaults to False.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/","title":"BaseVectorDB","text":""},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB","title":"<code>BaseVectorDB</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for managing vector database connections.</p>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base vector DB manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseVectorDBConfig</code>)           \u2013            <p>Configuration for the vector database connection.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.connect","title":"<code>connect(uri, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Connect to the vector database and set up the connection.</p> <p>Parameters:</p> <ul> <li> <code>uri</code>               (<code>str | Path</code>)           \u2013            <p>The URI or path to connect to the vector database.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the connection.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.insert_data","title":"<code>insert_data(data, overwrite=True)</code>  <code>abstractmethod</code>","text":"<p>Insert data into the vector database.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The data to be inserted.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to overwrite existing data. Defaults to True.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.delete_data","title":"<code>delete_data(filter_conditions)</code>  <code>abstractmethod</code>","text":"<p>Delete data from the vector database based on filter conditions.</p> <p>Parameters:</p> <ul> <li> <code>filter_conditions</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Conditions to filter which data to delete.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.update_data","title":"<code>update_data(filter_conditions, new_data)</code>  <code>abstractmethod</code>","text":"<p>Update existing data in the vector database based on filter conditions.</p> <p>Parameters:</p> <ul> <li> <code>filter_conditions</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Conditions to filter which data to update.</p> </li> <li> <code>new_data</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>New data to update the existing records with.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/base_vector_db/#tigergraphx.vector_search.vector_db.BaseVectorDB.query","title":"<code>query(query_embedding, k=10, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Perform a similarity search by vector and return results in the desired format.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The embedding vector to query.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of nearest neighbors to return. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of result identifiers.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/","title":"LanceDBManager","text":""},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager","title":"<code>LanceDBManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>Implementation of LanceDB vector database management.</p>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the LanceDB manager by connecting and setting up schema.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>LanceDBConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for LanceDB, either as a config object, dictionary, string, or path to configuration file.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.connect","title":"<code>connect(uri, **kwargs)</code>","text":"<p>Connect to LanceDB and initialize or open the specified table.</p> <p>Parameters:</p> <ul> <li> <code>uri</code>               (<code>str | Path</code>)           \u2013            <p>The URI to connect to the LanceDB database.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional connection parameters.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.get_table","title":"<code>get_table()</code>","text":"<p>Retrieve the current table.</p> <p>Returns:</p> <ul> <li> <code>Table</code> (              <code>Table</code> )          \u2013            <p>The LanceDB table object.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.insert_data","title":"<code>insert_data(data, overwrite=True)</code>","text":"<p>Insert data into the LanceDB table.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame containing the data to be inserted.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to overwrite existing data. Defaults to True.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.delete_data","title":"<code>delete_data(filter_conditions)</code>","text":"<p>Delete data from LanceDB based on filter conditions.</p> <p>Parameters:</p> <ul> <li> <code>filter_conditions</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Conditions to filter rows for deletion.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.update_data","title":"<code>update_data(filter_conditions, new_data)</code>","text":"<p>Update data in the LanceDB table based on filter conditions.</p> <p>Parameters:</p> <ul> <li> <code>filter_conditions</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Conditions to filter rows for updating.</p> </li> <li> <code>new_data</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Data to update matching rows with.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/lancedb_manager/#tigergraphx.vector_search.vector_db.LanceDBManager.query","title":"<code>query(query_embedding, k=10, **kwargs)</code>","text":"<p>Perform a similarity search by vector and return results as a list of IDs.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>The query vector for similarity search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of top results to retrieve. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the search.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of IDs from the search results.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the table is not initialized or no results are found.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/","title":"NanoVectorDBManager","text":""},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager","title":"<code>NanoVectorDBManager</code>","text":"<p>               Bases: <code>BaseVectorDB</code></p> <p>A wrapper class for NanoVectorDB that implements BaseVectorDB.</p>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the NanoVectorDBWrapper.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>NanoVectorDBConfig</code>)           \u2013            <p>Configuration for NanoVectorDB.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.connect","title":"<code>connect(uri, **kwargs)</code>","text":"<p>Connect to the vector database and set up the connection.</p> <p>Parameters:</p> <ul> <li> <code>uri</code>               (<code>str | Path</code>)           \u2013            <p>The URI or path to the database.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the connection.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.insert_data","title":"<code>insert_data(data, overwrite=True)</code>","text":"<p>Insert data into NanoVectorDB.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame containing the data to insert.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to overwrite existing data. Defaults to True.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.delete_data","title":"<code>delete_data(filter_conditions)</code>","text":"<p>Delete data from NanoVectorDB based on filter conditions.</p> <p>Parameters:</p> <ul> <li> <code>filter_conditions</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Conditions to filter rows for deletion.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.update_data","title":"<code>update_data(filter_conditions, new_data)</code>","text":"<p>Update existing data in NanoVectorDB.</p> <p>Parameters:</p> <ul> <li> <code>filter_conditions</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Conditions to filter rows for updating.</p> </li> <li> <code>new_data</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>New data to update the filtered rows with.</p> </li> </ul>"},{"location":"reference/02_vector_search/01_vector_db/nano_vectordb_manager/#tigergraphx.vector_search.vector_db.NanoVectorDBManager.query","title":"<code>query(query_embedding, k=10, **kwargs)</code>","text":"<p>Perform a similarity search and return results.</p> <p>Parameters:</p> <ul> <li> <code>query_embedding</code>               (<code>List[float]</code>)           \u2013            <p>Query embedding vector for similarity search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of top results to retrieve. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of IDs from the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/base_embedding/","title":"BaseEmbedding","text":""},{"location":"reference/02_vector_search/02_embedding/base_embedding/#tigergraphx.vector_search.embedding.BaseEmbedding","title":"<code>BaseEmbedding</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for text embedding models.</p>"},{"location":"reference/02_vector_search/02_embedding/base_embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base embedding model.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseEmbeddingConfig</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/base_embedding/#tigergraphx.vector_search.embedding.BaseEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously generate embeddings for a given text.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to generate embeddings for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>List[float]: A list of floats representing the text embedding.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/openai_embedding/","title":"OpenAIEmbedding","text":""},{"location":"reference/02_vector_search/02_embedding/openai_embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding","title":"<code>OpenAIEmbedding</code>","text":"<p>               Bases: <code>BaseEmbedding</code>, <code>RetryMixin</code></p> <p>OpenAI Embedding model wrapper with async embedding generation and robust retries.</p>"},{"location":"reference/02_vector_search/02_embedding/openai_embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAI Embedding wrapper.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIEmbeddingConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for the embedding model.</p> </li> </ul>"},{"location":"reference/02_vector_search/02_embedding/openai_embedding/#tigergraphx.vector_search.embedding.OpenAIEmbedding.generate_embedding","title":"<code>generate_embedding(text)</code>  <code>async</code>","text":"<p>Generate embedding asynchronously with retry for robustness.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to generate embeddings for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>List[float]: The normalized embedding vector.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/base_search_engine/","title":"BaseSearchEngine","text":""},{"location":"reference/02_vector_search/03_search/base_search_engine/#tigergraphx.vector_search.search.BaseSearchEngine","title":"<code>BaseSearchEngine</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a search engine that performs text-to-vector searches in a vector store.</p>"},{"location":"reference/02_vector_search/03_search/base_search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the search engine with an embedding model and a vector database.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>BaseEmbedding</code>)           \u2013            <p>The model used to generate text embeddings.</p> </li> <li> <code>vector_db</code>               (<code>BaseVectorDB</code>)           \u2013            <p>The vector database for storing and querying embeddings.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/base_search_engine/#tigergraphx.vector_search.search.BaseSearchEngine.search","title":"<code>search(text, k=10, **kwargs)</code>  <code>async</code>","text":"<p>Convert text to embedding and search in the vector database.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The input text to search.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to return. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments for the vector database query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of IDs corresponding to the search results.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/lancedb_search_engine/","title":"LanceDBSearchEngine","text":""},{"location":"reference/02_vector_search/03_search/lancedb_search_engine/#tigergraphx.vector_search.search.LanceDBSearchEngine","title":"<code>LanceDBSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and LanceDB.</p>"},{"location":"reference/02_vector_search/03_search/lancedb_search_engine/#tigergraphx.vector_search.search.LanceDBSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the LanceDBSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>LanceDBManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/02_vector_search/03_search/nano_vectordb_search_engine/","title":"NanoVectorDBSearchEngine","text":""},{"location":"reference/02_vector_search/03_search/nano_vectordb_search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine","title":"<code>NanoVectorDBSearchEngine</code>","text":"<p>               Bases: <code>BaseSearchEngine</code></p> <p>Search engine that performs text embedding and similarity search using OpenAI and NanoVectorDB.</p>"},{"location":"reference/02_vector_search/03_search/nano_vectordb_search_engine/#tigergraphx.vector_search.search.NanoVectorDBSearchEngine.__init__","title":"<code>__init__(embedding_model, vector_db)</code>","text":"<p>Initialize the NanoVectorDBSearchEngine.</p> <p>Parameters:</p> <ul> <li> <code>embedding_model</code>               (<code>OpenAIEmbedding</code>)           \u2013            <p>The embedding model used for text-to-vector conversion.</p> </li> <li> <code>vector_db</code>               (<code>NanoVectorDBManager</code>)           \u2013            <p>The vector database for similarity search.</p> </li> </ul>"},{"location":"reference/03_llm/base_llm_manager/","title":"BaseLLMManager","text":""},{"location":"reference/03_llm/base_llm_manager/#tigergraphx.llm.BaseLLMManager","title":"<code>BaseLLMManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM implementations.</p>"},{"location":"reference/03_llm/base_llm_manager/#tigergraphx.llm.BaseLLMManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the base LLM manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseLLMConfig</code>)           \u2013            <p>Configuration for the LLM.</p> </li> </ul>"},{"location":"reference/03_llm/base_llm_manager/#tigergraphx.llm.BaseLLMManager.get_llm","title":"<code>get_llm()</code>  <code>abstractmethod</code>","text":"<p>Retrieve the initialized LLM instance.</p> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The initialized LLM instance.</p> </li> </ul>"},{"location":"reference/03_llm/openai_manager/","title":"OpenAIManager","text":""},{"location":"reference/03_llm/openai_manager/#tigergraphx.llm.OpenAIManager","title":"<code>OpenAIManager</code>","text":"<p>               Bases: <code>BaseLLMManager</code></p> <p>Manages an asynchronous OpenAI instance for LLM operations.</p>"},{"location":"reference/03_llm/openai_manager/#tigergraphx.llm.OpenAIManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize OpenAIManager with OpenAI settings.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>OpenAIConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI settings.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the API key is not provided in the configuration.</p> </li> </ul>"},{"location":"reference/03_llm/openai_manager/#tigergraphx.llm.OpenAIManager.get_llm","title":"<code>get_llm()</code>","text":"<p>Retrieve the initialized async OpenAI instance.</p> <p>Returns:</p> <ul> <li> <code>AsyncOpenAI</code> (              <code>AsyncOpenAI</code> )          \u2013            <p>The initialized OpenAI instance.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/base_chat/","title":"BaseChat","text":""},{"location":"reference/03_llm/01_chat/base_chat/#tigergraphx.llm.chat.BaseChat","title":"<code>BaseChat</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for chat models.</p>"},{"location":"reference/03_llm/01_chat/base_chat/#tigergraphx.llm.chat.BaseChat.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the chat model with the given configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseChatConfig</code>)           \u2013            <p>Configuration for the chat model.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/base_chat/#tigergraphx.llm.chat.BaseChat.chat","title":"<code>chat(messages)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[Any]</code>)           \u2013            <p>A list of messages to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The generated response.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/openai_chat/","title":"OpenAIChat","text":""},{"location":"reference/03_llm/01_chat/openai_chat/#tigergraphx.llm.chat.OpenAIChat","title":"<code>OpenAIChat</code>","text":"<p>               Bases: <code>BaseChat</code>, <code>RetryMixin</code></p> <p>Implementation of BaseChat for OpenAI models.</p>"},{"location":"reference/03_llm/01_chat/openai_chat/#tigergraphx.llm.chat.OpenAIChat.__init__","title":"<code>__init__(llm_manager, config)</code>","text":"<p>Initialize the OpenAIChat with the provided LLM manager and configuration.</p> <p>Parameters:</p> <ul> <li> <code>llm_manager</code>               (<code>OpenAIManager</code>)           \u2013            <p>Manager for OpenAI LLM interactions.</p> </li> <li> <code>config</code>               (<code>OpenAIChatConfig | Dict | str | Path</code>)           \u2013            <p>Configuration for OpenAI chat.</p> </li> </ul>"},{"location":"reference/03_llm/01_chat/openai_chat/#tigergraphx.llm.chat.OpenAIChat.chat","title":"<code>chat(messages)</code>  <code>async</code>","text":"<p>Asynchronously process the messages and return the generated response.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>List[ChatCompletionMessageParam]</code>)           \u2013            <p>List of messages for chat completion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The generated response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RetryError</code>             \u2013            <p>If retry attempts are exhausted.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any unexpected errors during processing.</p> </li> </ul>"},{"location":"reference/04_config/base_config/","title":"BaseConfig","text":""},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig","title":"<code>BaseConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Base configuration class that extends Pydantic's BaseSettings. Provides utility methods to load configurations from various sources.</p>"},{"location":"reference/04_config/base_config/#tigergraphx.config.BaseConfig.ensure_config","title":"<code>ensure_config(config)</code>  <code>classmethod</code>","text":"<p>Ensure the config is an instance of the current config class.</p> <p>If the input is a dictionary, string, or path to a YAML/JSON file, it is loaded and converted into an instance of the class.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>T | Path | str | Dict</code>)           \u2013            <p>The input configuration, which can be an instance of the config class, a dictionary, a file path, or a string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>An instance of the current configuration class.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the provided file path does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the file type is unsupported.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the input type is not supported.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/loading_job_config/","title":"Loading Job Configuration","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig","title":"<code>LoadingJobConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a loading job consisting of multiple files.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.loading_job_name","title":"<code>loading_job_name: str = Field(description='The name of the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.files","title":"<code>files: List[FileConfig] = Field(description='A list of files included in the loading job.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.LoadingJobConfig.validate_file_aliases","title":"<code>validate_file_aliases(values)</code>","text":"<p>Ensure that all file_alias values are unique.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig","title":"<code>FileConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for a single file used in a loading job.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_alias","title":"<code>file_alias: str = Field(description='An alias for the file, used as a reference.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.file_path","title":"<code>file_path: Optional[str] = Field(default=None, description='The path to the file on disk.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.csv_parsing_options","title":"<code>csv_parsing_options: CsvParsingOptions = Field(default_factory=CsvParsingOptions, description='Options for parsing the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.node_mappings","title":"<code>node_mappings: Optional[List[NodeMappingConfig]] = Field(default=None, description='Node mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.edge_mappings","title":"<code>edge_mappings: Optional[List[EdgeMappingConfig]] = Field(default=None, description='Edge mappings defined for this file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.FileConfig.validate_mappings","title":"<code>validate_mappings(values)</code>","text":"<p>Ensure that at least one mapping (node or edge) exists.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions","title":"<code>CsvParsingOptions</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration options for CSV parsing.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.separator","title":"<code>separator: str = Field(default=',', description='The separator used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.header","title":"<code>header: bool = Field(default=True, description='Whether the CSV file contains a header row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.EOL","title":"<code>EOL: str = Field(default='\\\\n', description='The end-of-line character in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.CsvParsingOptions.quote","title":"<code>quote: Optional[QuoteType] = Field(default=QuoteType.DOUBLE, description='The type of quote used in the CSV file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig","title":"<code>NodeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping node attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.target_name","title":"<code>target_name: str = Field(description='The target node type name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.NodeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings: Dict[str, str | int] = Field(default={}, description='Mappings between file columns and node attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig","title":"<code>EdgeMappingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for mapping edge attributes from a file to the target schema.</p>"},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_name","title":"<code>target_name: str = Field(description='The target edge type name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.source_node_column","title":"<code>source_node_column: str | int = Field(description='The column representing the source node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.target_node_column","title":"<code>target_node_column: str | int = Field(description='The column representing the target node in the file.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/loading_job_config/#tigergraphx.config.graph_db.loading_job_config.EdgeMappingConfig.attribute_column_mappings","title":"<code>attribute_column_mappings: Dict[str, str | int] = Field(default={}, description='Mappings between file columns and edge attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/","title":"Schema Configuration","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.GraphSchema","title":"<code>GraphSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph, including nodes and edges.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.GraphSchema.graph_name","title":"<code>graph_name: str = Field(description='The name of the graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.GraphSchema.nodes","title":"<code>nodes: Dict[str, NodeSchema] = Field(description='A dictionary of node type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.GraphSchema.edges","title":"<code>edges: Dict[str, EdgeSchema] = Field(description='A dictionary of edge type names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.GraphSchema.validate_edge_references","title":"<code>validate_edge_references(values)</code>","text":"<p>Ensure all edges reference existing nodes in the graph schema.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.NodeSchema","title":"<code>NodeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph node type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.NodeSchema.primary_key","title":"<code>primary_key: str = Field(description='The primary key for the node type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.NodeSchema.attributes","title":"<code>attributes: Dict[str, AttributeSchema] = Field(description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.NodeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.NodeSchema.validate_primary_key_and_attributes","title":"<code>validate_primary_key_and_attributes(values)</code>","text":"<p>Validate that the primary key is present in attributes.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.EdgeSchema","title":"<code>EdgeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph edge type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.EdgeSchema.is_directed_edge","title":"<code>is_directed_edge: bool = Field(description='Whether the edge is directed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.EdgeSchema.from_node_type","title":"<code>from_node_type: str = Field(description='The type of the source node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.EdgeSchema.to_node_type","title":"<code>to_node_type: str = Field(description='The type of the target node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.EdgeSchema.attributes","title":"<code>attributes: Dict[str, AttributeSchema] = Field(description='A dictionary of attribute names to their schemas.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.EdgeSchema.parse_attributes","title":"<code>parse_attributes(values)</code>","text":"<p>Parse shorthand attributes into full AttributeSchema.</p> <p>Parameters:</p> <ul> <li> <code>values</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Input values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Parsed values with attributes as AttributeSchema.</p> </li> </ul>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.EdgeSchema.validate_attributes","title":"<code>validate_attributes(values)</code>","text":"<p>Validate attributes in the EdgeSchema.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.AttributeSchema","title":"<code>AttributeSchema</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema for a graph attribute.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.AttributeSchema.data_type","title":"<code>data_type: DataType = Field(description='The data type of the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.AttributeSchema.default_value","title":"<code>default_value: Optional[int | float | bool | str] = Field(default=None, description='The default value for the attribute.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.AttributeSchema.PYTHON_TYPES","title":"<code>PYTHON_TYPES: Dict[DataType, Type | Tuple[Type, ...]] = {DataType.INT: int, DataType.UINT: int, DataType.FLOAT: (float, int), DataType.DOUBLE: (float, int), DataType.BOOL: bool, DataType.STRING: str, DataType.DATETIME: str}</code>  <code>class-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.AttributeSchema.validate_default_value","title":"<code>validate_default_value()</code>","text":"<p>Validate that the default value matches the expected data type.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported data types.</p>"},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType.INT","title":"<code>INT = 'INT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType.UINT","title":"<code>UINT = 'UINT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType.FLOAT","title":"<code>FLOAT = 'FLOAT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType.DOUBLE","title":"<code>DOUBLE = 'DOUBLE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType.BOOL","title":"<code>BOOL = 'BOOL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType.STRING","title":"<code>STRING = 'STRING'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/schema_config/#tigergraphx.config.graph_db.schema_config.DataType.DATETIME","title":"<code>DATETIME = 'DATETIME'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/","title":"TigerGraphConnectionConfig","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig","title":"<code>TigerGraphConnectionConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for connecting to a TigerGraph instance.</p>"},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.host","title":"<code>host: HttpUrl = Field(default=HttpUrl('http://127.0.0.1'), description='The host URL for the TigerGraph connection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.username","title":"<code>username: str = Field(default='tigergraph', description='The username for TigerGraph authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.password","title":"<code>password: str = Field(default='tigergraph', description='The password for TigerGraph authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.restpp_port","title":"<code>restpp_port: int | str = Field(default='9000', description='The port for REST++ API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.graph_studio_port","title":"<code>graph_studio_port: int | str = Field(default='14240', description='The port for Graph Studio.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/01_graph_db/tigergraph_connection_config/#tigergraphx.config.graph_db.tigergraph_connection_config.TigerGraphConnectionConfig.add_http_if_missing","title":"<code>add_http_if_missing(value)</code>","text":"<p>Ensure the host URL has an HTTP or HTTPS scheme.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>str | HttpUrl</code>)           \u2013            <p>The input host value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | HttpUrl</code>           \u2013            <p>str | HttpUrl: The host value with an HTTP or HTTPS scheme.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the host is invalid.</p> </li> </ul>"},{"location":"reference/04_config/02_query/neighbor_spec/","title":"NeighborSpec","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec","title":"<code>NeighborSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting neighbors in a graph query.</p>"},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_nodes","title":"<code>start_nodes: str | List[str] = Field(..., description='List of starting node IDs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.start_node_type","title":"<code>start_node_type: str = Field(..., description='The type of the start node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.edge_types","title":"<code>edge_types: Optional[str | List[str]] = Field(None, description='List of allowed edge types for traversal.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.target_node_types","title":"<code>target_node_types: Optional[str | List[str]] = Field(None, description='List of allowed target node types.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.filter_expression","title":"<code>filter_expression: Optional[str] = Field(None, description='A string defining complex filtering logic.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.return_attributes","title":"<code>return_attributes: Optional[str | List[str]] = Field(None, description='List of attributes to include in the results.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/neighbor_spec/#tigergraphx.config.query.NeighborSpec.limit","title":"<code>limit: Optional[int] = Field(None, description='Maximum number of results to return.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/","title":"NodeSpec","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec","title":"<code>NodeSpec</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Specification for selecting nodes in a graph query.</p>"},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.node_type","title":"<code>node_type: Optional[str] = Field(..., description='The type of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.filter_expression","title":"<code>filter_expression: Optional[str] = Field(None, description='A string defining filtering logic for the node selection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.return_attributes","title":"<code>return_attributes: Optional[str | List[str]] = Field(None, description='List of attributes to include in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/02_query/node_spec/#tigergraphx.config.query.NodeSpec.limit","title":"<code>limit: Optional[int] = Field(None, description='Maximum number of nodes to select.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/","title":"Chat Settings","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig","title":"<code>BaseChatConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.BaseChatConfig.type","title":"<code>type: str = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig","title":"<code>OpenAIChatConfig</code>","text":"<p>               Bases: <code>BaseChatConfig</code></p> <p>Configuration class for OpenAI Chat models.</p>"},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.type","title":"<code>type: str = Field(default='OpenAI', description='Default type for OpenAIChatConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.model","title":"<code>model: str = Field(default='gpt-4o-mini', description='Default OpenAI model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/chat_settings/#tigergraphx.config.settings.chat_settings.OpenAIChatConfig.max_retries","title":"<code>max_retries: int = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/","title":"Embedding Settings","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig","title":"<code>BaseEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.BaseEmbeddingConfig.type","title":"<code>type: str = Field(description='Mandatory base type; derived classes can override or set a default.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig","title":"<code>OpenAIEmbeddingConfig</code>","text":"<p>               Bases: <code>BaseEmbeddingConfig</code></p> <p>Configuration class for OpenAI Embedding models.</p>"},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.type","title":"<code>type: str = Field(default='OpenAI', description='Default type for OpenAIEmbeddingConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.model","title":"<code>model: str = Field(default='text-embedding-3-small', description='Default OpenAI embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_tokens","title":"<code>max_tokens: int = Field(default=8191, description='Maximum number of tokens supported.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.max_retries","title":"<code>max_retries: int = Field(default=10, description='Maximum number of retries for API calls.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/embedding_settings/#tigergraphx.config.settings.embedding_settings.OpenAIEmbeddingConfig.encoding_name","title":"<code>encoding_name: str = Field(default='cl100k_base', description='Token encoding name used by the model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/","title":"LLM Settings","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig","title":"<code>BaseLLMConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for LLM.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.BaseLLMConfig.type","title":"<code>type: str = Field(description='Mandatory type field for identifying the LLM type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig","title":"<code>OpenAIConfig</code>","text":"<p>               Bases: <code>BaseLLMConfig</code></p> <p>Configuration class for OpenAI.</p>"},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.type","title":"<code>type: str = Field(default='OpenAI', description='Default type for OpenAIConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.api_key","title":"<code>api_key: str = Field(alias='OPENAI_API_KEY', description='API key for authentication with OpenAI.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.base_url","title":"<code>base_url: Optional[str] = Field(default=None, description='Custom base URL for OpenAI API.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.organization","title":"<code>organization: Optional[str] = Field(default=None, description='OpenAI organization ID (if applicable).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.max_retries","title":"<code>max_retries: int = Field(default=10, description='Maximum number of retries for failed API requests.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/llm_settings/#tigergraphx.config.settings.llm_settings.OpenAIConfig.request_timeout","title":"<code>request_timeout: float = Field(default=180.0, description='Request timeout in seconds.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/","title":"Settings","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Application settings, including configurations for vector databases, LLMs, embeddings, and chat models.</p>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.vector_db","title":"<code>vector_db: LanceDBConfig | BaseVectorDBConfig = Field(description='Configuration for the vector database.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.llm","title":"<code>llm: OpenAIConfig | BaseLLMConfig = Field(description='Configuration for the language model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.embedding","title":"<code>embedding: OpenAIEmbeddingConfig | BaseEmbeddingConfig = Field(description='Configuration for the embedding model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.chat","title":"<code>chat: OpenAIChatConfig | BaseChatConfig = Field(description='Configuration for the chat model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_vector_db","title":"<code>validate_vector_db(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the vector_db field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the vector database.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseVectorDBConfig</code> (              <code>BaseVectorDBConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of vector database is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_llm","title":"<code>validate_llm(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the llm field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the language model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseLLMConfig</code> (              <code>BaseLLMConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of language model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_embedding","title":"<code>validate_embedding(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the embedding field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the embedding model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseEmbeddingConfig</code> (              <code>BaseEmbeddingConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of embedding model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/settings/#tigergraphx.config.settings.Settings.validate_chat","title":"<code>validate_chat(value)</code>  <code>classmethod</code>","text":"<p>Validate and instantiate the chat field.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The input configuration for the chat model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseChatConfig</code> (              <code>BaseChatConfig</code> )          \u2013            <p>The instantiated configuration.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the type of chat model is unknown.</p> </li> </ul>"},{"location":"reference/04_config/03_settings/vector_db_settings/","title":"Vector DB Settings","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig","title":"<code>BaseVectorDBConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Base configuration class for vector databases.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.BaseVectorDBConfig.type","title":"<code>type: str = Field(description='Mandatory type field to identify the database type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig","title":"<code>LanceDBConfig</code>","text":"<p>               Bases: <code>BaseVectorDBConfig</code></p> <p>Configuration class for LanceDB.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.type","title":"<code>type: str = Field(default='LanceDB', description='Default type for LanceDBConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.table_name","title":"<code>table_name: str = Field(default='entity_description_embeddings', description='Default table name for embeddings.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.uri","title":"<code>uri: str | Path = Field(description='URI or path to the LanceDB resource.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.api_key","title":"<code>api_key: Optional[str] = Field(default=None, description='API key for authentication, if required.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.region","title":"<code>region: str = Field(default='us-east-1', description='Default region for LanceDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.host_override","title":"<code>host_override: Optional[str] = Field(default=None, description='Host override for custom LanceDB endpoints.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.read_consistency_interval","title":"<code>read_consistency_interval: Optional[timedelta] = Field(default=None, description='Read consistency interval for queries.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.LanceDBConfig.request_thread_pool","title":"<code>request_thread_pool: Optional[int | ThreadPoolExecutor] = Field(default=None, description='Thread pool for managing requests.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig","title":"<code>NanoVectorDBConfig</code>","text":"<p>               Bases: <code>BaseVectorDBConfig</code></p> <p>Configuration class for NanoVectorDB.</p>"},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.type","title":"<code>type: str = Field(default='NanoVectorDB', description='Default type for NanoVectorDBConfig.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.storage_file","title":"<code>storage_file: str | Path = Field(default='nano-vectordb.json', description='Path to the storage file for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/04_config/03_settings/vector_db_settings/#tigergraphx.config.settings.vector_db_settings.NanoVectorDBConfig.embedding_dim","title":"<code>embedding_dim: int = Field(default=1536, description='Default embedding dimension for NanoVectorDB.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/05_graphrag/base_context_builder/","title":"BaseContextBuilder","text":""},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder","title":"<code>BaseContextBuilder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for building context using graph data and a search engine.</p> <p>Attributes:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>)           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>               (<code>Optional[BaseSearchEngine]</code>)           \u2013            <p>The search engine for retrieving top-k objects.</p> </li> <li> <code>token_encoder</code>               (<code>Encoding</code>)           \u2013            <p>Token encoder for text tokenization.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.__init__","title":"<code>__init__(graph, single_batch, search_engine=None, token_encoder=None)</code>","text":"<p>Initialize the BaseContextBuilder.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>The graph object.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>)           \u2013            <p>Whether to process data in a single batch.</p> </li> <li> <code>search_engine</code>               (<code>Optional[BaseSearchEngine]</code>, default:                   <code>None</code> )           \u2013            <p>The search engine for similarity searches.</p> </li> <li> <code>token_encoder</code>               (<code>Optional[Encoding]</code>, default:                   <code>None</code> )           \u2013            <p>Token encoder for text tokenization. Defaults to \"cl100k_base\".</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.build_context","title":"<code>build_context(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to build context.</p> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>str | List[str]: The generated context as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.batch_and_convert_to_text","title":"<code>batch_and_convert_to_text(graph_data, section_name, single_batch=False, max_tokens=12000)</code>","text":"<p>Convert graph data to a formatted string or list of strings in batches based on token count.</p> <p>Parameters:</p> <ul> <li> <code>graph_data</code>               (<code>DataFrame</code>)           \u2013            <p>The graph data to convert.</p> </li> <li> <code>section_name</code>               (<code>str</code>)           \u2013            <p>The section name for the header.</p> </li> <li> <code>single_batch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to process data in a single batch. Defaults to False.</p> </li> <li> <code>max_tokens</code>               (<code>int</code>, default:                   <code>12000</code> )           \u2013            <p>Maximum number of tokens per batch. Defaults to 12000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | List[str]</code>           \u2013            <p>str | List[str]: The formatted graph data as a string or list of strings.</p> </li> </ul>"},{"location":"reference/05_graphrag/base_context_builder/#tigergraphx.graphrag.BaseContextBuilder.retrieve_top_k_objects","title":"<code>retrieve_top_k_objects(query, k=10, **kwargs)</code>  <code>async</code>","text":"<p>Retrieve the top-k objects most similar to the query.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str</code>)           \u2013            <p>The query string.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of top results to retrieve. Defaults to 10.</p> </li> <li> <code>**kwargs</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters for the search engine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of the top-k results.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>k</code> is less than or equal to 0 or if the search engine is not initialized.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/","title":"ParquetProcessor","text":""},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor","title":"<code>ParquetProcessor</code>","text":"<p>A class to process Parquet files and generate CSV files with custom transformations.</p>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.__init__","title":"<code>__init__(input_dir, output_dir)</code>","text":"<p>Initialize the ParquetProcessor with input and output directories.</p> <p>Parameters:</p> <ul> <li> <code>input_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory containing the input Parquet files.</p> </li> <li> <code>output_dir</code>               (<code>str | Path</code>)           \u2013            <p>Directory to save the output CSV files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.save_dataframe_to_csv","title":"<code>save_dataframe_to_csv(df, csv_file_name)</code>","text":"<p>Save a DataFrame or Series to a CSV file with specific formatting.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame | Series</code>)           \u2013            <p>The DataFrame or Series to save.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.convert_parquet_to_csv","title":"<code>convert_parquet_to_csv(parquet_file_name, columns, csv_file_name)</code>","text":"<p>Convert a Parquet file to a CSV file with specific columns.</p> <p>Parameters:</p> <ul> <li> <code>parquet_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the input Parquet file.</p> </li> <li> <code>columns</code>               (<code>List[str]</code>)           \u2013            <p>List of columns to include in the output CSV.</p> </li> <li> <code>csv_file_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.create_relationship_file","title":"<code>create_relationship_file(df, element_list_name, element_name, collection_name, collection_new_name, output_name)</code>","text":"<p>Generate a CSV file for relationship mapping based on input DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>Input DataFrame containing relationship data.</p> </li> <li> <code>element_list_name</code>               (<code>str</code>)           \u2013            <p>Name of the column containing element lists.</p> </li> <li> <code>element_name</code>               (<code>str</code>)           \u2013            <p>Name of the element to map.</p> </li> <li> <code>collection_name</code>               (<code>str</code>)           \u2013            <p>Name of the collection column.</p> </li> <li> <code>collection_new_name</code>               (<code>str</code>)           \u2013            <p>New name for the collection in the output.</p> </li> <li> <code>output_name</code>               (<code>str</code>)           \u2013            <p>Name of the output CSV file.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_parquet_files","title":"<code>process_parquet_files(configs)</code>","text":"<p>Process a list of Parquet file configurations and convert them to CSV.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for processing Parquet files.</p> </li> </ul>"},{"location":"reference/06_pipelines/parquet_processor/#tigergraphx.pipelines.ParquetProcessor.process_relationship_files","title":"<code>process_relationship_files(configs)</code>","text":"<p>Process a list of relationship file configurations and generate CSV files.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>List[Dict[str, Any]]</code>)           \u2013            <p>List of configuration dictionaries for generating relationship files.</p> </li> </ul>"},{"location":"reference/07_utils/retry_mixin/","title":"RetryMixin","text":""},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin","title":"<code>RetryMixin</code>","text":"<p>Mixin for initializing a retry mechanism.</p>"},{"location":"reference/07_utils/retry_mixin/#tigergraphx.utils.RetryMixin.initialize_retryer","title":"<code>initialize_retryer(max_retries, max_wait)</code>","text":"<p>Initialize the retry mechanism.</p> <p>Parameters:</p> <ul> <li> <code>max_retries</code>               (<code>int</code>)           \u2013            <p>Maximum number of retry attempts.</p> </li> <li> <code>max_wait</code>               (<code>int</code>)           \u2013            <p>Maximum wait time between retries in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncRetrying</code> (              <code>AsyncRetrying</code> )          \u2013            <p>Configured retrying instance.</p> </li> </ul>"}]}